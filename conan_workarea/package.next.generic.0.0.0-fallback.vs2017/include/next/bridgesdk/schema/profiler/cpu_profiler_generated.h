// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CPUPROFILER_GUISCHEMA_H_
#define FLATBUFFERS_GENERATED_CPUPROFILER_GUISCHEMA_H_

#include "flatbuffers/flatbuffers.h"

#include "next/bridgesdk/schema/profiler/basic_info_generated.h"

namespace GuiSchema {

struct CpuUsage;
struct CpuUsageBuilder;
struct CpuUsageT;

struct Threads;
struct ThreadsBuilder;
struct ThreadsT;

struct CpuProfiler;
struct CpuProfilerBuilder;
struct CpuProfilerT;

struct CpuProfilerList;
struct CpuProfilerListBuilder;
struct CpuProfilerListT;

struct CpuUsageT : public flatbuffers::NativeTable {
  typedef CpuUsage TableType;
  uint8_t core = 0;
  float usage = 0.0f;
};

struct CpuUsage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CpuUsageT NativeTableType;
  typedef CpuUsageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CORE = 4,
    VT_USAGE = 6
  };
  uint8_t core() const {
    return GetField<uint8_t>(VT_CORE, 0);
  }
  float usage() const {
    return GetField<float>(VT_USAGE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CORE, 1) &&
           VerifyField<float>(verifier, VT_USAGE, 4) &&
           verifier.EndTable();
  }
  CpuUsageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CpuUsageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CpuUsage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CpuUsageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CpuUsageBuilder {
  typedef CpuUsage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_core(uint8_t core) {
    fbb_.AddElement<uint8_t>(CpuUsage::VT_CORE, core, 0);
  }
  void add_usage(float usage) {
    fbb_.AddElement<float>(CpuUsage::VT_USAGE, usage, 0.0f);
  }
  explicit CpuUsageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CpuUsage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CpuUsage>(end);
    return o;
  }
};

inline flatbuffers::Offset<CpuUsage> CreateCpuUsage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t core = 0,
    float usage = 0.0f) {
  CpuUsageBuilder builder_(_fbb);
  builder_.add_usage(usage);
  builder_.add_core(core);
  return builder_.Finish();
}

flatbuffers::Offset<CpuUsage> CreateCpuUsage(flatbuffers::FlatBufferBuilder &_fbb, const CpuUsageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ThreadsT : public flatbuffers::NativeTable {
  typedef Threads TableType;
  uint64_t tid = 0;
  uint8_t tcore = 0;
  float tusage = 0.0f;
};

struct Threads FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ThreadsT NativeTableType;
  typedef ThreadsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TID = 4,
    VT_TCORE = 6,
    VT_TUSAGE = 8
  };
  uint64_t tid() const {
    return GetField<uint64_t>(VT_TID, 0);
  }
  uint8_t tcore() const {
    return GetField<uint8_t>(VT_TCORE, 0);
  }
  float tusage() const {
    return GetField<float>(VT_TUSAGE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TID, 8) &&
           VerifyField<uint8_t>(verifier, VT_TCORE, 1) &&
           VerifyField<float>(verifier, VT_TUSAGE, 4) &&
           verifier.EndTable();
  }
  ThreadsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ThreadsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Threads> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ThreadsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ThreadsBuilder {
  typedef Threads Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tid(uint64_t tid) {
    fbb_.AddElement<uint64_t>(Threads::VT_TID, tid, 0);
  }
  void add_tcore(uint8_t tcore) {
    fbb_.AddElement<uint8_t>(Threads::VT_TCORE, tcore, 0);
  }
  void add_tusage(float tusage) {
    fbb_.AddElement<float>(Threads::VT_TUSAGE, tusage, 0.0f);
  }
  explicit ThreadsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Threads> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Threads>(end);
    return o;
  }
};

inline flatbuffers::Offset<Threads> CreateThreads(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t tid = 0,
    uint8_t tcore = 0,
    float tusage = 0.0f) {
  ThreadsBuilder builder_(_fbb);
  builder_.add_tid(tid);
  builder_.add_tusage(tusage);
  builder_.add_tcore(tcore);
  return builder_.Finish();
}

flatbuffers::Offset<Threads> CreateThreads(flatbuffers::FlatBufferBuilder &_fbb, const ThreadsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CpuProfilerT : public flatbuffers::NativeTable {
  typedef CpuProfiler TableType;
  std::unique_ptr<profiler::BasicInformationT> basic{};
  uint64_t pid = 0;
  std::vector<std::unique_ptr<GuiSchema::CpuUsageT>> cpu{};
  std::vector<std::unique_ptr<GuiSchema::ThreadsT>> threads{};
  uint8_t threadCount = 0;
  CpuProfilerT() = default;
  CpuProfilerT(const CpuProfilerT &o);
  CpuProfilerT(CpuProfilerT&&) FLATBUFFERS_NOEXCEPT = default;
  CpuProfilerT &operator=(CpuProfilerT o) FLATBUFFERS_NOEXCEPT;
};

struct CpuProfiler FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CpuProfilerT NativeTableType;
  typedef CpuProfilerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASIC = 4,
    VT_PID = 6,
    VT_CPU = 8,
    VT_THREADS = 10,
    VT_THREADCOUNT = 12
  };
  const profiler::BasicInformation *basic() const {
    return GetPointer<const profiler::BasicInformation *>(VT_BASIC);
  }
  uint64_t pid() const {
    return GetField<uint64_t>(VT_PID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::CpuUsage>> *cpu() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::CpuUsage>> *>(VT_CPU);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Threads>> *threads() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Threads>> *>(VT_THREADS);
  }
  uint8_t threadCount() const {
    return GetField<uint8_t>(VT_THREADCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASIC) &&
           verifier.VerifyTable(basic()) &&
           VerifyField<uint64_t>(verifier, VT_PID, 8) &&
           VerifyOffset(verifier, VT_CPU) &&
           verifier.VerifyVector(cpu()) &&
           verifier.VerifyVectorOfTables(cpu()) &&
           VerifyOffset(verifier, VT_THREADS) &&
           verifier.VerifyVector(threads()) &&
           verifier.VerifyVectorOfTables(threads()) &&
           VerifyField<uint8_t>(verifier, VT_THREADCOUNT, 1) &&
           verifier.EndTable();
  }
  CpuProfilerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CpuProfilerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CpuProfiler> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CpuProfilerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CpuProfilerBuilder {
  typedef CpuProfiler Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basic(flatbuffers::Offset<profiler::BasicInformation> basic) {
    fbb_.AddOffset(CpuProfiler::VT_BASIC, basic);
  }
  void add_pid(uint64_t pid) {
    fbb_.AddElement<uint64_t>(CpuProfiler::VT_PID, pid, 0);
  }
  void add_cpu(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::CpuUsage>>> cpu) {
    fbb_.AddOffset(CpuProfiler::VT_CPU, cpu);
  }
  void add_threads(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Threads>>> threads) {
    fbb_.AddOffset(CpuProfiler::VT_THREADS, threads);
  }
  void add_threadCount(uint8_t threadCount) {
    fbb_.AddElement<uint8_t>(CpuProfiler::VT_THREADCOUNT, threadCount, 0);
  }
  explicit CpuProfilerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CpuProfiler> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CpuProfiler>(end);
    return o;
  }
};

inline flatbuffers::Offset<CpuProfiler> CreateCpuProfiler(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<profiler::BasicInformation> basic = 0,
    uint64_t pid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::CpuUsage>>> cpu = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Threads>>> threads = 0,
    uint8_t threadCount = 0) {
  CpuProfilerBuilder builder_(_fbb);
  builder_.add_pid(pid);
  builder_.add_threads(threads);
  builder_.add_cpu(cpu);
  builder_.add_basic(basic);
  builder_.add_threadCount(threadCount);
  return builder_.Finish();
}

inline flatbuffers::Offset<CpuProfiler> CreateCpuProfilerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<profiler::BasicInformation> basic = 0,
    uint64_t pid = 0,
    const std::vector<flatbuffers::Offset<GuiSchema::CpuUsage>> *cpu = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Threads>> *threads = nullptr,
    uint8_t threadCount = 0) {
  auto cpu__ = cpu ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::CpuUsage>>(*cpu) : 0;
  auto threads__ = threads ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Threads>>(*threads) : 0;
  return GuiSchema::CreateCpuProfiler(
      _fbb,
      basic,
      pid,
      cpu__,
      threads__,
      threadCount);
}

flatbuffers::Offset<CpuProfiler> CreateCpuProfiler(flatbuffers::FlatBufferBuilder &_fbb, const CpuProfilerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CpuProfilerListT : public flatbuffers::NativeTable {
  typedef CpuProfilerList TableType;
  std::vector<std::unique_ptr<GuiSchema::CpuProfilerT>> processes{};
  CpuProfilerListT() = default;
  CpuProfilerListT(const CpuProfilerListT &o);
  CpuProfilerListT(CpuProfilerListT&&) FLATBUFFERS_NOEXCEPT = default;
  CpuProfilerListT &operator=(CpuProfilerListT o) FLATBUFFERS_NOEXCEPT;
};

struct CpuProfilerList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CpuProfilerListT NativeTableType;
  typedef CpuProfilerListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROCESSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::CpuProfiler>> *processes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::CpuProfiler>> *>(VT_PROCESSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROCESSES) &&
           verifier.VerifyVector(processes()) &&
           verifier.VerifyVectorOfTables(processes()) &&
           verifier.EndTable();
  }
  CpuProfilerListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CpuProfilerListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CpuProfilerList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CpuProfilerListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CpuProfilerListBuilder {
  typedef CpuProfilerList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_processes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::CpuProfiler>>> processes) {
    fbb_.AddOffset(CpuProfilerList::VT_PROCESSES, processes);
  }
  explicit CpuProfilerListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CpuProfilerList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CpuProfilerList>(end);
    return o;
  }
};

inline flatbuffers::Offset<CpuProfilerList> CreateCpuProfilerList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::CpuProfiler>>> processes = 0) {
  CpuProfilerListBuilder builder_(_fbb);
  builder_.add_processes(processes);
  return builder_.Finish();
}

inline flatbuffers::Offset<CpuProfilerList> CreateCpuProfilerListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GuiSchema::CpuProfiler>> *processes = nullptr) {
  auto processes__ = processes ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::CpuProfiler>>(*processes) : 0;
  return GuiSchema::CreateCpuProfilerList(
      _fbb,
      processes__);
}

flatbuffers::Offset<CpuProfilerList> CreateCpuProfilerList(flatbuffers::FlatBufferBuilder &_fbb, const CpuProfilerListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CpuUsageT *CpuUsage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CpuUsageT>(new CpuUsageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CpuUsage::UnPackTo(CpuUsageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = core(); _o->core = _e; }
  { auto _e = usage(); _o->usage = _e; }
}

inline flatbuffers::Offset<CpuUsage> CpuUsage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CpuUsageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCpuUsage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CpuUsage> CreateCpuUsage(flatbuffers::FlatBufferBuilder &_fbb, const CpuUsageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CpuUsageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _core = _o->core;
  auto _usage = _o->usage;
  return GuiSchema::CreateCpuUsage(
      _fbb,
      _core,
      _usage);
}

inline ThreadsT *Threads::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ThreadsT>(new ThreadsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Threads::UnPackTo(ThreadsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tid(); _o->tid = _e; }
  { auto _e = tcore(); _o->tcore = _e; }
  { auto _e = tusage(); _o->tusage = _e; }
}

inline flatbuffers::Offset<Threads> Threads::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ThreadsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateThreads(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Threads> CreateThreads(flatbuffers::FlatBufferBuilder &_fbb, const ThreadsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ThreadsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tid = _o->tid;
  auto _tcore = _o->tcore;
  auto _tusage = _o->tusage;
  return GuiSchema::CreateThreads(
      _fbb,
      _tid,
      _tcore,
      _tusage);
}

inline CpuProfilerT::CpuProfilerT(const CpuProfilerT &o)
      : basic((o.basic) ? new profiler::BasicInformationT(*o.basic) : nullptr),
        pid(o.pid),
        threadCount(o.threadCount) {
  cpu.reserve(o.cpu.size());
  for (const auto &v : o.cpu) { cpu.emplace_back((v) ? new GuiSchema::CpuUsageT(*v) : nullptr); }
  threads.reserve(o.threads.size());
  for (const auto &v : o.threads) { threads.emplace_back((v) ? new GuiSchema::ThreadsT(*v) : nullptr); }
}

inline CpuProfilerT &CpuProfilerT::operator=(CpuProfilerT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basic, o.basic);
  std::swap(pid, o.pid);
  std::swap(cpu, o.cpu);
  std::swap(threads, o.threads);
  std::swap(threadCount, o.threadCount);
  return *this;
}

inline CpuProfilerT *CpuProfiler::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CpuProfilerT>(new CpuProfilerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CpuProfiler::UnPackTo(CpuProfilerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basic(); if (_e) { if(_o->basic) { _e->UnPackTo(_o->basic.get(), _resolver); } else { _o->basic = std::unique_ptr<profiler::BasicInformationT>(_e->UnPack(_resolver)); } } }
  { auto _e = pid(); _o->pid = _e; }
  { auto _e = cpu(); if (_e) { _o->cpu.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->cpu[_i]) { _e->Get(_i)->UnPackTo(_o->cpu[_i].get(), _resolver); } else { _o->cpu[_i] = std::unique_ptr<GuiSchema::CpuUsageT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = threads(); if (_e) { _o->threads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->threads[_i]) { _e->Get(_i)->UnPackTo(_o->threads[_i].get(), _resolver); } else { _o->threads[_i] = std::unique_ptr<GuiSchema::ThreadsT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = threadCount(); _o->threadCount = _e; }
}

inline flatbuffers::Offset<CpuProfiler> CpuProfiler::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CpuProfilerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCpuProfiler(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CpuProfiler> CreateCpuProfiler(flatbuffers::FlatBufferBuilder &_fbb, const CpuProfilerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CpuProfilerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basic = _o->basic ? CreateBasicInformation(_fbb, _o->basic.get(), _rehasher) : 0;
  auto _pid = _o->pid;
  auto _cpu = _o->cpu.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::CpuUsage>> (_o->cpu.size(), [](size_t i, _VectorArgs *__va) { return CreateCpuUsage(*__va->__fbb, __va->__o->cpu[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _threads = _o->threads.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Threads>> (_o->threads.size(), [](size_t i, _VectorArgs *__va) { return CreateThreads(*__va->__fbb, __va->__o->threads[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _threadCount = _o->threadCount;
  return GuiSchema::CreateCpuProfiler(
      _fbb,
      _basic,
      _pid,
      _cpu,
      _threads,
      _threadCount);
}

inline CpuProfilerListT::CpuProfilerListT(const CpuProfilerListT &o) {
  processes.reserve(o.processes.size());
  for (const auto &v : o.processes) { processes.emplace_back((v) ? new GuiSchema::CpuProfilerT(*v) : nullptr); }
}

inline CpuProfilerListT &CpuProfilerListT::operator=(CpuProfilerListT o) FLATBUFFERS_NOEXCEPT {
  std::swap(processes, o.processes);
  return *this;
}

inline CpuProfilerListT *CpuProfilerList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CpuProfilerListT>(new CpuProfilerListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CpuProfilerList::UnPackTo(CpuProfilerListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = processes(); if (_e) { _o->processes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->processes[_i]) { _e->Get(_i)->UnPackTo(_o->processes[_i].get(), _resolver); } else { _o->processes[_i] = std::unique_ptr<GuiSchema::CpuProfilerT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<CpuProfilerList> CpuProfilerList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CpuProfilerListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCpuProfilerList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CpuProfilerList> CreateCpuProfilerList(flatbuffers::FlatBufferBuilder &_fbb, const CpuProfilerListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CpuProfilerListT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _processes = _o->processes.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::CpuProfiler>> (_o->processes.size(), [](size_t i, _VectorArgs *__va) { return CreateCpuProfiler(*__va->__fbb, __va->__o->processes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return GuiSchema::CreateCpuProfilerList(
      _fbb,
      _processes);
}

inline const GuiSchema::CpuProfilerList *GetCpuProfilerList(const void *buf) {
  return flatbuffers::GetRoot<GuiSchema::CpuProfilerList>(buf);
}

inline const GuiSchema::CpuProfilerList *GetSizePrefixedCpuProfilerList(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<GuiSchema::CpuProfilerList>(buf);
}

inline const char *CpuProfilerListIdentifier() {
  return "CP01";
}

inline bool CpuProfilerListBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, CpuProfilerListIdentifier());
}

inline bool SizePrefixedCpuProfilerListBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, CpuProfilerListIdentifier(), true);
}

inline bool VerifyCpuProfilerListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GuiSchema::CpuProfilerList>(CpuProfilerListIdentifier());
}

inline bool VerifySizePrefixedCpuProfilerListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GuiSchema::CpuProfilerList>(CpuProfilerListIdentifier());
}

inline void FinishCpuProfilerListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GuiSchema::CpuProfilerList> root) {
  fbb.Finish(root, CpuProfilerListIdentifier());
}

inline void FinishSizePrefixedCpuProfilerListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GuiSchema::CpuProfilerList> root) {
  fbb.FinishSizePrefixed(root, CpuProfilerListIdentifier());
}

inline std::unique_ptr<GuiSchema::CpuProfilerListT> UnPackCpuProfilerList(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GuiSchema::CpuProfilerListT>(GetCpuProfilerList(buf)->UnPack(res));
}

inline std::unique_ptr<GuiSchema::CpuProfilerListT> UnPackSizePrefixedCpuProfilerList(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GuiSchema::CpuProfilerListT>(GetSizePrefixedCpuProfilerList(buf)->UnPack(res));
}

}  // namespace GuiSchema

#endif  // FLATBUFFERS_GENERATED_CPUPROFILER_GUISCHEMA_H_
