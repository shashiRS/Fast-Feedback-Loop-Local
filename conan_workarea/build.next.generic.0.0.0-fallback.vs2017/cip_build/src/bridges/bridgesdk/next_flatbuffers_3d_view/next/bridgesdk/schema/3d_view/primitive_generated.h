// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PRIMITIVE_GUISCHEMA_H_
#define FLATBUFFERS_GENERATED_PRIMITIVE_GUISCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace GuiSchema {

struct XYZ;

struct PrimitiveBasic;
struct PrimitiveBasicBuilder;
struct PrimitiveBasicT;

struct Sphere;
struct SphereBuilder;
struct SphereT;

struct Circle;
struct CircleBuilder;
struct CircleT;

struct Rectangle;
struct RectangleBuilder;
struct RectangleT;

struct Triangle;
struct TriangleBuilder;
struct TriangleT;

struct Line;
struct LineBuilder;
struct LineT;

struct Cone;
struct ConeBuilder;
struct ConeT;

struct Pyramid;
struct PyramidBuilder;
struct PyramidT;

struct Text;
struct TextBuilder;
struct TextT;

struct BoxOutline;
struct BoxOutlineBuilder;
struct BoxOutlineT;

struct Arc;
struct ArcBuilder;
struct ArcT;

struct Ellipse;
struct EllipseBuilder;
struct EllipseT;

struct PrimitiveList;
struct PrimitiveListBuilder;
struct PrimitiveListT;

enum class PrimitiveType : int32_t {
  None = -1,
  circle = 0,
  rectangle = 1,
  triangle = 2,
  text = 3,
  sphere = 4,
  line = 5,
  cone = 6,
  boxOutline = 7,
  pyramid = 8,
  arc = 9,
  ellipse = 10,
  MIN = None,
  MAX = ellipse
};

inline const PrimitiveType (&EnumValuesPrimitiveType())[12] {
  static const PrimitiveType values[] = {
    PrimitiveType::None,
    PrimitiveType::circle,
    PrimitiveType::rectangle,
    PrimitiveType::triangle,
    PrimitiveType::text,
    PrimitiveType::sphere,
    PrimitiveType::line,
    PrimitiveType::cone,
    PrimitiveType::boxOutline,
    PrimitiveType::pyramid,
    PrimitiveType::arc,
    PrimitiveType::ellipse
  };
  return values;
}

inline const char * const *EnumNamesPrimitiveType() {
  static const char * const names[13] = {
    "None",
    "circle",
    "rectangle",
    "triangle",
    "text",
    "sphere",
    "line",
    "cone",
    "boxOutline",
    "pyramid",
    "arc",
    "ellipse",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrimitiveType(PrimitiveType e) {
  if (flatbuffers::IsOutRange(e, PrimitiveType::None, PrimitiveType::ellipse)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(PrimitiveType::None);
  return EnumNamesPrimitiveType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) XYZ FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  XYZ()
      : x_(0),
        y_(0),
        z_(0) {
  }
  XYZ(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(XYZ, 12);

struct PrimitiveBasicT : public flatbuffers::NativeTable {
  typedef PrimitiveBasic TableType;
  GuiSchema::PrimitiveType type = GuiSchema::PrimitiveType::circle;
  int32_t id = 0;
  std::string color{};
  double opacity = 0.0;
};

struct PrimitiveBasic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PrimitiveBasicT NativeTableType;
  typedef PrimitiveBasicBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ID = 6,
    VT_COLOR = 8,
    VT_OPACITY = 10
  };
  GuiSchema::PrimitiveType type() const {
    return static_cast<GuiSchema::PrimitiveType>(GetField<int32_t>(VT_TYPE, 0));
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *color() const {
    return GetPointer<const flatbuffers::String *>(VT_COLOR);
  }
  double opacity() const {
    return GetField<double>(VT_OPACITY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyString(color()) &&
           VerifyField<double>(verifier, VT_OPACITY, 8) &&
           verifier.EndTable();
  }
  PrimitiveBasicT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PrimitiveBasicT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PrimitiveBasic> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveBasicT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PrimitiveBasicBuilder {
  typedef PrimitiveBasic Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(GuiSchema::PrimitiveType type) {
    fbb_.AddElement<int32_t>(PrimitiveBasic::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(PrimitiveBasic::VT_ID, id, 0);
  }
  void add_color(flatbuffers::Offset<flatbuffers::String> color) {
    fbb_.AddOffset(PrimitiveBasic::VT_COLOR, color);
  }
  void add_opacity(double opacity) {
    fbb_.AddElement<double>(PrimitiveBasic::VT_OPACITY, opacity, 0.0);
  }
  explicit PrimitiveBasicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PrimitiveBasic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PrimitiveBasic>(end);
    return o;
  }
};

inline flatbuffers::Offset<PrimitiveBasic> CreatePrimitiveBasic(
    flatbuffers::FlatBufferBuilder &_fbb,
    GuiSchema::PrimitiveType type = GuiSchema::PrimitiveType::circle,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> color = 0,
    double opacity = 0.0) {
  PrimitiveBasicBuilder builder_(_fbb);
  builder_.add_opacity(opacity);
  builder_.add_color(color);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PrimitiveBasic> CreatePrimitiveBasicDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GuiSchema::PrimitiveType type = GuiSchema::PrimitiveType::circle,
    int32_t id = 0,
    const char *color = nullptr,
    double opacity = 0.0) {
  auto color__ = color ? _fbb.CreateString(color) : 0;
  return GuiSchema::CreatePrimitiveBasic(
      _fbb,
      type,
      id,
      color__,
      opacity);
}

flatbuffers::Offset<PrimitiveBasic> CreatePrimitiveBasic(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveBasicT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SphereT : public flatbuffers::NativeTable {
  typedef Sphere TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  std::unique_ptr<GuiSchema::XYZ> scale{};
  std::unique_ptr<GuiSchema::XYZ> rotation{};
  double radius = 1.0;
  SphereT() = default;
  SphereT(const SphereT &o);
  SphereT(SphereT&&) FLATBUFFERS_NOEXCEPT = default;
  SphereT &operator=(SphereT o) FLATBUFFERS_NOEXCEPT;
};

struct Sphere FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SphereT NativeTableType;
  typedef SphereBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_SCALE = 8,
    VT_ROTATION = 10,
    VT_RADIUS = 12
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  const GuiSchema::XYZ *scale() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_SCALE);
  }
  const GuiSchema::XYZ *rotation() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_ROTATION);
  }
  double radius() const {
    return GetField<double>(VT_RADIUS, 1.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_SCALE, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_ROTATION, 4) &&
           VerifyField<double>(verifier, VT_RADIUS, 8) &&
           verifier.EndTable();
  }
  SphereT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SphereT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sphere> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SphereT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SphereBuilder {
  typedef Sphere Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Sphere::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(Sphere::VT_CENTERPOINT, centerPoint);
  }
  void add_scale(const GuiSchema::XYZ *scale) {
    fbb_.AddStruct(Sphere::VT_SCALE, scale);
  }
  void add_rotation(const GuiSchema::XYZ *rotation) {
    fbb_.AddStruct(Sphere::VT_ROTATION, rotation);
  }
  void add_radius(double radius) {
    fbb_.AddElement<double>(Sphere::VT_RADIUS, radius, 1.0);
  }
  explicit SphereBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sphere> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sphere>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sphere> CreateSphere(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    const GuiSchema::XYZ *scale = nullptr,
    const GuiSchema::XYZ *rotation = nullptr,
    double radius = 1.0) {
  SphereBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_rotation(rotation);
  builder_.add_scale(scale);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

flatbuffers::Offset<Sphere> CreateSphere(flatbuffers::FlatBufferBuilder &_fbb, const SphereT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CircleT : public flatbuffers::NativeTable {
  typedef Circle TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  std::unique_ptr<GuiSchema::XYZ> scale{};
  std::unique_ptr<GuiSchema::XYZ> rotation{};
  double radius = 1.0;
  CircleT() = default;
  CircleT(const CircleT &o);
  CircleT(CircleT&&) FLATBUFFERS_NOEXCEPT = default;
  CircleT &operator=(CircleT o) FLATBUFFERS_NOEXCEPT;
};

struct Circle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CircleT NativeTableType;
  typedef CircleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_SCALE = 8,
    VT_ROTATION = 10,
    VT_RADIUS = 12
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  const GuiSchema::XYZ *scale() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_SCALE);
  }
  const GuiSchema::XYZ *rotation() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_ROTATION);
  }
  double radius() const {
    return GetField<double>(VT_RADIUS, 1.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_SCALE, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_ROTATION, 4) &&
           VerifyField<double>(verifier, VT_RADIUS, 8) &&
           verifier.EndTable();
  }
  CircleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CircleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Circle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CircleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CircleBuilder {
  typedef Circle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Circle::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(Circle::VT_CENTERPOINT, centerPoint);
  }
  void add_scale(const GuiSchema::XYZ *scale) {
    fbb_.AddStruct(Circle::VT_SCALE, scale);
  }
  void add_rotation(const GuiSchema::XYZ *rotation) {
    fbb_.AddStruct(Circle::VT_ROTATION, rotation);
  }
  void add_radius(double radius) {
    fbb_.AddElement<double>(Circle::VT_RADIUS, radius, 1.0);
  }
  explicit CircleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Circle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Circle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Circle> CreateCircle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    const GuiSchema::XYZ *scale = nullptr,
    const GuiSchema::XYZ *rotation = nullptr,
    double radius = 1.0) {
  CircleBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_rotation(rotation);
  builder_.add_scale(scale);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

flatbuffers::Offset<Circle> CreateCircle(flatbuffers::FlatBufferBuilder &_fbb, const CircleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RectangleT : public flatbuffers::NativeTable {
  typedef Rectangle TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  std::unique_ptr<GuiSchema::XYZ> scale{};
  std::unique_ptr<GuiSchema::XYZ> rotation{};
  bool filled = false;
  bool dashed = false;
  double lineWidth = 1.0;
  RectangleT() = default;
  RectangleT(const RectangleT &o);
  RectangleT(RectangleT&&) FLATBUFFERS_NOEXCEPT = default;
  RectangleT &operator=(RectangleT o) FLATBUFFERS_NOEXCEPT;
};

struct Rectangle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RectangleT NativeTableType;
  typedef RectangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_SCALE = 8,
    VT_ROTATION = 10,
    VT_FILLED = 12,
    VT_DASHED = 14,
    VT_LINEWIDTH = 16
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  const GuiSchema::XYZ *scale() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_SCALE);
  }
  const GuiSchema::XYZ *rotation() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_ROTATION);
  }
  bool filled() const {
    return GetField<uint8_t>(VT_FILLED, 0) != 0;
  }
  bool dashed() const {
    return GetField<uint8_t>(VT_DASHED, 0) != 0;
  }
  double lineWidth() const {
    return GetField<double>(VT_LINEWIDTH, 1.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_SCALE, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_ROTATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_FILLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DASHED, 1) &&
           VerifyField<double>(verifier, VT_LINEWIDTH, 8) &&
           verifier.EndTable();
  }
  RectangleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RectangleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Rectangle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RectangleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RectangleBuilder {
  typedef Rectangle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Rectangle::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(Rectangle::VT_CENTERPOINT, centerPoint);
  }
  void add_scale(const GuiSchema::XYZ *scale) {
    fbb_.AddStruct(Rectangle::VT_SCALE, scale);
  }
  void add_rotation(const GuiSchema::XYZ *rotation) {
    fbb_.AddStruct(Rectangle::VT_ROTATION, rotation);
  }
  void add_filled(bool filled) {
    fbb_.AddElement<uint8_t>(Rectangle::VT_FILLED, static_cast<uint8_t>(filled), 0);
  }
  void add_dashed(bool dashed) {
    fbb_.AddElement<uint8_t>(Rectangle::VT_DASHED, static_cast<uint8_t>(dashed), 0);
  }
  void add_lineWidth(double lineWidth) {
    fbb_.AddElement<double>(Rectangle::VT_LINEWIDTH, lineWidth, 1.0);
  }
  explicit RectangleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rectangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rectangle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rectangle> CreateRectangle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    const GuiSchema::XYZ *scale = nullptr,
    const GuiSchema::XYZ *rotation = nullptr,
    bool filled = false,
    bool dashed = false,
    double lineWidth = 1.0) {
  RectangleBuilder builder_(_fbb);
  builder_.add_lineWidth(lineWidth);
  builder_.add_rotation(rotation);
  builder_.add_scale(scale);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  builder_.add_dashed(dashed);
  builder_.add_filled(filled);
  return builder_.Finish();
}

flatbuffers::Offset<Rectangle> CreateRectangle(flatbuffers::FlatBufferBuilder &_fbb, const RectangleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TriangleT : public flatbuffers::NativeTable {
  typedef Triangle TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  std::unique_ptr<GuiSchema::XYZ> scale{};
  std::unique_ptr<GuiSchema::XYZ> rotation{};
  double lineWidth = 1.0;
  TriangleT() = default;
  TriangleT(const TriangleT &o);
  TriangleT(TriangleT&&) FLATBUFFERS_NOEXCEPT = default;
  TriangleT &operator=(TriangleT o) FLATBUFFERS_NOEXCEPT;
};

struct Triangle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TriangleT NativeTableType;
  typedef TriangleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_SCALE = 8,
    VT_ROTATION = 10,
    VT_LINEWIDTH = 12
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  const GuiSchema::XYZ *scale() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_SCALE);
  }
  const GuiSchema::XYZ *rotation() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_ROTATION);
  }
  double lineWidth() const {
    return GetField<double>(VT_LINEWIDTH, 1.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_SCALE, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_ROTATION, 4) &&
           VerifyField<double>(verifier, VT_LINEWIDTH, 8) &&
           verifier.EndTable();
  }
  TriangleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TriangleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Triangle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TriangleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TriangleBuilder {
  typedef Triangle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Triangle::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(Triangle::VT_CENTERPOINT, centerPoint);
  }
  void add_scale(const GuiSchema::XYZ *scale) {
    fbb_.AddStruct(Triangle::VT_SCALE, scale);
  }
  void add_rotation(const GuiSchema::XYZ *rotation) {
    fbb_.AddStruct(Triangle::VT_ROTATION, rotation);
  }
  void add_lineWidth(double lineWidth) {
    fbb_.AddElement<double>(Triangle::VT_LINEWIDTH, lineWidth, 1.0);
  }
  explicit TriangleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Triangle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Triangle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Triangle> CreateTriangle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    const GuiSchema::XYZ *scale = nullptr,
    const GuiSchema::XYZ *rotation = nullptr,
    double lineWidth = 1.0) {
  TriangleBuilder builder_(_fbb);
  builder_.add_lineWidth(lineWidth);
  builder_.add_rotation(rotation);
  builder_.add_scale(scale);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

flatbuffers::Offset<Triangle> CreateTriangle(flatbuffers::FlatBufferBuilder &_fbb, const TriangleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LineT : public flatbuffers::NativeTable {
  typedef Line TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::vector<GuiSchema::XYZ> points{};
  double lineWidth = 1.0;
  LineT() = default;
  LineT(const LineT &o);
  LineT(LineT&&) FLATBUFFERS_NOEXCEPT = default;
  LineT &operator=(LineT o) FLATBUFFERS_NOEXCEPT;
};

struct Line FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LineT NativeTableType;
  typedef LineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_POINTS = 6,
    VT_LINEWIDTH = 8
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const flatbuffers::Vector<const GuiSchema::XYZ *> *points() const {
    return GetPointer<const flatbuffers::Vector<const GuiSchema::XYZ *> *>(VT_POINTS);
  }
  double lineWidth() const {
    return GetField<double>(VT_LINEWIDTH, 1.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           VerifyField<double>(verifier, VT_LINEWIDTH, 8) &&
           verifier.EndTable();
  }
  LineT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LineT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Line> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LineT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LineBuilder {
  typedef Line Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Line::VT_BASICINFO, basicInfo);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const GuiSchema::XYZ *>> points) {
    fbb_.AddOffset(Line::VT_POINTS, points);
  }
  void add_lineWidth(double lineWidth) {
    fbb_.AddElement<double>(Line::VT_LINEWIDTH, lineWidth, 1.0);
  }
  explicit LineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Line> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Line>(end);
    return o;
  }
};

inline flatbuffers::Offset<Line> CreateLine(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GuiSchema::XYZ *>> points = 0,
    double lineWidth = 1.0) {
  LineBuilder builder_(_fbb);
  builder_.add_lineWidth(lineWidth);
  builder_.add_points(points);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

inline flatbuffers::Offset<Line> CreateLineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const std::vector<GuiSchema::XYZ> *points = nullptr,
    double lineWidth = 1.0) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<GuiSchema::XYZ>(*points) : 0;
  return GuiSchema::CreateLine(
      _fbb,
      basicInfo,
      points__,
      lineWidth);
}

flatbuffers::Offset<Line> CreateLine(flatbuffers::FlatBufferBuilder &_fbb, const LineT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConeT : public flatbuffers::NativeTable {
  typedef Cone TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  std::unique_ptr<GuiSchema::XYZ> scale{};
  std::unique_ptr<GuiSchema::XYZ> rotation{};
  double height = 1.0;
  double radius = 0.5;
  ConeT() = default;
  ConeT(const ConeT &o);
  ConeT(ConeT&&) FLATBUFFERS_NOEXCEPT = default;
  ConeT &operator=(ConeT o) FLATBUFFERS_NOEXCEPT;
};

struct Cone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConeT NativeTableType;
  typedef ConeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_SCALE = 8,
    VT_ROTATION = 10,
    VT_HEIGHT = 12,
    VT_RADIUS = 14
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  const GuiSchema::XYZ *scale() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_SCALE);
  }
  const GuiSchema::XYZ *rotation() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_ROTATION);
  }
  double height() const {
    return GetField<double>(VT_HEIGHT, 1.0);
  }
  double radius() const {
    return GetField<double>(VT_RADIUS, 0.5);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_SCALE, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_ROTATION, 4) &&
           VerifyField<double>(verifier, VT_HEIGHT, 8) &&
           VerifyField<double>(verifier, VT_RADIUS, 8) &&
           verifier.EndTable();
  }
  ConeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cone> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConeBuilder {
  typedef Cone Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Cone::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(Cone::VT_CENTERPOINT, centerPoint);
  }
  void add_scale(const GuiSchema::XYZ *scale) {
    fbb_.AddStruct(Cone::VT_SCALE, scale);
  }
  void add_rotation(const GuiSchema::XYZ *rotation) {
    fbb_.AddStruct(Cone::VT_ROTATION, rotation);
  }
  void add_height(double height) {
    fbb_.AddElement<double>(Cone::VT_HEIGHT, height, 1.0);
  }
  void add_radius(double radius) {
    fbb_.AddElement<double>(Cone::VT_RADIUS, radius, 0.5);
  }
  explicit ConeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Cone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cone>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cone> CreateCone(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    const GuiSchema::XYZ *scale = nullptr,
    const GuiSchema::XYZ *rotation = nullptr,
    double height = 1.0,
    double radius = 0.5) {
  ConeBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_height(height);
  builder_.add_rotation(rotation);
  builder_.add_scale(scale);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

flatbuffers::Offset<Cone> CreateCone(flatbuffers::FlatBufferBuilder &_fbb, const ConeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PyramidT : public flatbuffers::NativeTable {
  typedef Pyramid TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  std::unique_ptr<GuiSchema::XYZ> scale{};
  std::unique_ptr<GuiSchema::XYZ> rotation{};
  double height = 1.0;
  double radius = 0.5;
  PyramidT() = default;
  PyramidT(const PyramidT &o);
  PyramidT(PyramidT&&) FLATBUFFERS_NOEXCEPT = default;
  PyramidT &operator=(PyramidT o) FLATBUFFERS_NOEXCEPT;
};

struct Pyramid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PyramidT NativeTableType;
  typedef PyramidBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_SCALE = 8,
    VT_ROTATION = 10,
    VT_HEIGHT = 12,
    VT_RADIUS = 14
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  const GuiSchema::XYZ *scale() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_SCALE);
  }
  const GuiSchema::XYZ *rotation() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_ROTATION);
  }
  double height() const {
    return GetField<double>(VT_HEIGHT, 1.0);
  }
  double radius() const {
    return GetField<double>(VT_RADIUS, 0.5);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_SCALE, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_ROTATION, 4) &&
           VerifyField<double>(verifier, VT_HEIGHT, 8) &&
           VerifyField<double>(verifier, VT_RADIUS, 8) &&
           verifier.EndTable();
  }
  PyramidT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PyramidT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pyramid> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PyramidT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PyramidBuilder {
  typedef Pyramid Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Pyramid::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(Pyramid::VT_CENTERPOINT, centerPoint);
  }
  void add_scale(const GuiSchema::XYZ *scale) {
    fbb_.AddStruct(Pyramid::VT_SCALE, scale);
  }
  void add_rotation(const GuiSchema::XYZ *rotation) {
    fbb_.AddStruct(Pyramid::VT_ROTATION, rotation);
  }
  void add_height(double height) {
    fbb_.AddElement<double>(Pyramid::VT_HEIGHT, height, 1.0);
  }
  void add_radius(double radius) {
    fbb_.AddElement<double>(Pyramid::VT_RADIUS, radius, 0.5);
  }
  explicit PyramidBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pyramid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pyramid>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pyramid> CreatePyramid(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    const GuiSchema::XYZ *scale = nullptr,
    const GuiSchema::XYZ *rotation = nullptr,
    double height = 1.0,
    double radius = 0.5) {
  PyramidBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_height(height);
  builder_.add_rotation(rotation);
  builder_.add_scale(scale);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

flatbuffers::Offset<Pyramid> CreatePyramid(flatbuffers::FlatBufferBuilder &_fbb, const PyramidT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TextT : public flatbuffers::NativeTable {
  typedef Text TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  std::string text{};
  int32_t fontSize = 0;
  TextT() = default;
  TextT(const TextT &o);
  TextT(TextT&&) FLATBUFFERS_NOEXCEPT = default;
  TextT &operator=(TextT o) FLATBUFFERS_NOEXCEPT;
};

struct Text FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextT NativeTableType;
  typedef TextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_TEXT = 8,
    VT_FONTSIZE = 10
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  int32_t fontSize() const {
    return GetField<int32_t>(VT_FONTSIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyField<int32_t>(verifier, VT_FONTSIZE, 4) &&
           verifier.EndTable();
  }
  TextT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Text> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextBuilder {
  typedef Text Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Text::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(Text::VT_CENTERPOINT, centerPoint);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Text::VT_TEXT, text);
  }
  void add_fontSize(int32_t fontSize) {
    fbb_.AddElement<int32_t>(Text::VT_FONTSIZE, fontSize, 0);
  }
  explicit TextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Text> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Text>(end);
    return o;
  }
};

inline flatbuffers::Offset<Text> CreateText(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    int32_t fontSize = 0) {
  TextBuilder builder_(_fbb);
  builder_.add_fontSize(fontSize);
  builder_.add_text(text);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

inline flatbuffers::Offset<Text> CreateTextDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    const char *text = nullptr,
    int32_t fontSize = 0) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return GuiSchema::CreateText(
      _fbb,
      basicInfo,
      centerPoint,
      text__,
      fontSize);
}

flatbuffers::Offset<Text> CreateText(flatbuffers::FlatBufferBuilder &_fbb, const TextT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BoxOutlineT : public flatbuffers::NativeTable {
  typedef BoxOutline TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  std::unique_ptr<GuiSchema::XYZ> scale{};
  std::unique_ptr<GuiSchema::XYZ> rotation{};
  BoxOutlineT() = default;
  BoxOutlineT(const BoxOutlineT &o);
  BoxOutlineT(BoxOutlineT&&) FLATBUFFERS_NOEXCEPT = default;
  BoxOutlineT &operator=(BoxOutlineT o) FLATBUFFERS_NOEXCEPT;
};

struct BoxOutline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoxOutlineT NativeTableType;
  typedef BoxOutlineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_SCALE = 8,
    VT_ROTATION = 10
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  const GuiSchema::XYZ *scale() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_SCALE);
  }
  const GuiSchema::XYZ *rotation() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_ROTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_SCALE, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_ROTATION, 4) &&
           verifier.EndTable();
  }
  BoxOutlineT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoxOutlineT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BoxOutline> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoxOutlineT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoxOutlineBuilder {
  typedef BoxOutline Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(BoxOutline::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(BoxOutline::VT_CENTERPOINT, centerPoint);
  }
  void add_scale(const GuiSchema::XYZ *scale) {
    fbb_.AddStruct(BoxOutline::VT_SCALE, scale);
  }
  void add_rotation(const GuiSchema::XYZ *rotation) {
    fbb_.AddStruct(BoxOutline::VT_ROTATION, rotation);
  }
  explicit BoxOutlineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BoxOutline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoxOutline>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoxOutline> CreateBoxOutline(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    const GuiSchema::XYZ *scale = nullptr,
    const GuiSchema::XYZ *rotation = nullptr) {
  BoxOutlineBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_scale(scale);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

flatbuffers::Offset<BoxOutline> CreateBoxOutline(flatbuffers::FlatBufferBuilder &_fbb, const BoxOutlineT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ArcT : public flatbuffers::NativeTable {
  typedef Arc TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  float radius = 0.0f;
  float startAngle = 0.0f;
  float endAngle = 0.0f;
  double lineWidth = 1.0;
  ArcT() = default;
  ArcT(const ArcT &o);
  ArcT(ArcT&&) FLATBUFFERS_NOEXCEPT = default;
  ArcT &operator=(ArcT o) FLATBUFFERS_NOEXCEPT;
};

struct Arc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArcT NativeTableType;
  typedef ArcBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_RADIUS = 8,
    VT_STARTANGLE = 10,
    VT_ENDANGLE = 12,
    VT_LINEWIDTH = 14
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  float startAngle() const {
    return GetField<float>(VT_STARTANGLE, 0.0f);
  }
  float endAngle() const {
    return GetField<float>(VT_ENDANGLE, 0.0f);
  }
  double lineWidth() const {
    return GetField<double>(VT_LINEWIDTH, 1.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_STARTANGLE, 4) &&
           VerifyField<float>(verifier, VT_ENDANGLE, 4) &&
           VerifyField<double>(verifier, VT_LINEWIDTH, 8) &&
           verifier.EndTable();
  }
  ArcT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ArcT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Arc> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArcT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ArcBuilder {
  typedef Arc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Arc::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(Arc::VT_CENTERPOINT, centerPoint);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(Arc::VT_RADIUS, radius, 0.0f);
  }
  void add_startAngle(float startAngle) {
    fbb_.AddElement<float>(Arc::VT_STARTANGLE, startAngle, 0.0f);
  }
  void add_endAngle(float endAngle) {
    fbb_.AddElement<float>(Arc::VT_ENDANGLE, endAngle, 0.0f);
  }
  void add_lineWidth(double lineWidth) {
    fbb_.AddElement<double>(Arc::VT_LINEWIDTH, lineWidth, 1.0);
  }
  explicit ArcBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Arc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Arc>(end);
    return o;
  }
};

inline flatbuffers::Offset<Arc> CreateArc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    float radius = 0.0f,
    float startAngle = 0.0f,
    float endAngle = 0.0f,
    double lineWidth = 1.0) {
  ArcBuilder builder_(_fbb);
  builder_.add_lineWidth(lineWidth);
  builder_.add_endAngle(endAngle);
  builder_.add_startAngle(startAngle);
  builder_.add_radius(radius);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

flatbuffers::Offset<Arc> CreateArc(flatbuffers::FlatBufferBuilder &_fbb, const ArcT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EllipseT : public flatbuffers::NativeTable {
  typedef Ellipse TableType;
  std::unique_ptr<GuiSchema::PrimitiveBasicT> basicInfo{};
  std::unique_ptr<GuiSchema::XYZ> centerPoint{};
  float radiusX = 0.0f;
  float radiusY = 0.0f;
  float startAngle = 0.0f;
  float endAngle = 0.0f;
  std::unique_ptr<GuiSchema::XYZ> rotation{};
  double lineWidth = 1.0;
  EllipseT() = default;
  EllipseT(const EllipseT &o);
  EllipseT(EllipseT&&) FLATBUFFERS_NOEXCEPT = default;
  EllipseT &operator=(EllipseT o) FLATBUFFERS_NOEXCEPT;
};

struct Ellipse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EllipseT NativeTableType;
  typedef EllipseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASICINFO = 4,
    VT_CENTERPOINT = 6,
    VT_RADIUSX = 8,
    VT_RADIUSY = 10,
    VT_STARTANGLE = 12,
    VT_ENDANGLE = 14,
    VT_ROTATION = 16,
    VT_LINEWIDTH = 18
  };
  const GuiSchema::PrimitiveBasic *basicInfo() const {
    return GetPointer<const GuiSchema::PrimitiveBasic *>(VT_BASICINFO);
  }
  const GuiSchema::XYZ *centerPoint() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_CENTERPOINT);
  }
  float radiusX() const {
    return GetField<float>(VT_RADIUSX, 0.0f);
  }
  float radiusY() const {
    return GetField<float>(VT_RADIUSY, 0.0f);
  }
  float startAngle() const {
    return GetField<float>(VT_STARTANGLE, 0.0f);
  }
  float endAngle() const {
    return GetField<float>(VT_ENDANGLE, 0.0f);
  }
  const GuiSchema::XYZ *rotation() const {
    return GetStruct<const GuiSchema::XYZ *>(VT_ROTATION);
  }
  double lineWidth() const {
    return GetField<double>(VT_LINEWIDTH, 1.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASICINFO) &&
           verifier.VerifyTable(basicInfo()) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_CENTERPOINT, 4) &&
           VerifyField<float>(verifier, VT_RADIUSX, 4) &&
           VerifyField<float>(verifier, VT_RADIUSY, 4) &&
           VerifyField<float>(verifier, VT_STARTANGLE, 4) &&
           VerifyField<float>(verifier, VT_ENDANGLE, 4) &&
           VerifyField<GuiSchema::XYZ>(verifier, VT_ROTATION, 4) &&
           VerifyField<double>(verifier, VT_LINEWIDTH, 8) &&
           verifier.EndTable();
  }
  EllipseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EllipseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Ellipse> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EllipseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EllipseBuilder {
  typedef Ellipse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_basicInfo(flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo) {
    fbb_.AddOffset(Ellipse::VT_BASICINFO, basicInfo);
  }
  void add_centerPoint(const GuiSchema::XYZ *centerPoint) {
    fbb_.AddStruct(Ellipse::VT_CENTERPOINT, centerPoint);
  }
  void add_radiusX(float radiusX) {
    fbb_.AddElement<float>(Ellipse::VT_RADIUSX, radiusX, 0.0f);
  }
  void add_radiusY(float radiusY) {
    fbb_.AddElement<float>(Ellipse::VT_RADIUSY, radiusY, 0.0f);
  }
  void add_startAngle(float startAngle) {
    fbb_.AddElement<float>(Ellipse::VT_STARTANGLE, startAngle, 0.0f);
  }
  void add_endAngle(float endAngle) {
    fbb_.AddElement<float>(Ellipse::VT_ENDANGLE, endAngle, 0.0f);
  }
  void add_rotation(const GuiSchema::XYZ *rotation) {
    fbb_.AddStruct(Ellipse::VT_ROTATION, rotation);
  }
  void add_lineWidth(double lineWidth) {
    fbb_.AddElement<double>(Ellipse::VT_LINEWIDTH, lineWidth, 1.0);
  }
  explicit EllipseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Ellipse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ellipse>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ellipse> CreateEllipse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveBasic> basicInfo = 0,
    const GuiSchema::XYZ *centerPoint = nullptr,
    float radiusX = 0.0f,
    float radiusY = 0.0f,
    float startAngle = 0.0f,
    float endAngle = 0.0f,
    const GuiSchema::XYZ *rotation = nullptr,
    double lineWidth = 1.0) {
  EllipseBuilder builder_(_fbb);
  builder_.add_lineWidth(lineWidth);
  builder_.add_rotation(rotation);
  builder_.add_endAngle(endAngle);
  builder_.add_startAngle(startAngle);
  builder_.add_radiusY(radiusY);
  builder_.add_radiusX(radiusX);
  builder_.add_centerPoint(centerPoint);
  builder_.add_basicInfo(basicInfo);
  return builder_.Finish();
}

flatbuffers::Offset<Ellipse> CreateEllipse(flatbuffers::FlatBufferBuilder &_fbb, const EllipseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PrimitiveListT : public flatbuffers::NativeTable {
  typedef PrimitiveList TableType;
  std::vector<std::unique_ptr<GuiSchema::CircleT>> circles{};
  std::vector<std::unique_ptr<GuiSchema::RectangleT>> rectangles{};
  std::vector<std::unique_ptr<GuiSchema::TriangleT>> triangles{};
  std::vector<std::unique_ptr<GuiSchema::TextT>> texts{};
  std::vector<std::unique_ptr<GuiSchema::SphereT>> spheres{};
  std::vector<std::unique_ptr<GuiSchema::LineT>> lines{};
  std::vector<std::unique_ptr<GuiSchema::ConeT>> cones{};
  std::vector<std::unique_ptr<GuiSchema::BoxOutlineT>> boxOutlines{};
  std::vector<std::unique_ptr<GuiSchema::PyramidT>> pyramids{};
  std::vector<std::unique_ptr<GuiSchema::ArcT>> arcs{};
  std::vector<std::unique_ptr<GuiSchema::EllipseT>> ellipses{};
  PrimitiveListT() = default;
  PrimitiveListT(const PrimitiveListT &o);
  PrimitiveListT(PrimitiveListT&&) FLATBUFFERS_NOEXCEPT = default;
  PrimitiveListT &operator=(PrimitiveListT o) FLATBUFFERS_NOEXCEPT;
};

struct PrimitiveList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PrimitiveListT NativeTableType;
  typedef PrimitiveListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CIRCLES = 4,
    VT_RECTANGLES = 6,
    VT_TRIANGLES = 8,
    VT_TEXTS = 10,
    VT_SPHERES = 12,
    VT_LINES = 14,
    VT_CONES = 16,
    VT_BOXOUTLINES = 18,
    VT_PYRAMIDS = 20,
    VT_ARCS = 22,
    VT_ELLIPSES = 24
  };
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Circle>> *circles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Circle>> *>(VT_CIRCLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Rectangle>> *rectangles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Rectangle>> *>(VT_RECTANGLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Triangle>> *triangles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Triangle>> *>(VT_TRIANGLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Text>> *texts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Text>> *>(VT_TEXTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Sphere>> *spheres() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Sphere>> *>(VT_SPHERES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Line>> *lines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Line>> *>(VT_LINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Cone>> *cones() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Cone>> *>(VT_CONES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::BoxOutline>> *boxOutlines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::BoxOutline>> *>(VT_BOXOUTLINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Pyramid>> *pyramids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Pyramid>> *>(VT_PYRAMIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Arc>> *arcs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Arc>> *>(VT_ARCS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Ellipse>> *ellipses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Ellipse>> *>(VT_ELLIPSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CIRCLES) &&
           verifier.VerifyVector(circles()) &&
           verifier.VerifyVectorOfTables(circles()) &&
           VerifyOffset(verifier, VT_RECTANGLES) &&
           verifier.VerifyVector(rectangles()) &&
           verifier.VerifyVectorOfTables(rectangles()) &&
           VerifyOffset(verifier, VT_TRIANGLES) &&
           verifier.VerifyVector(triangles()) &&
           verifier.VerifyVectorOfTables(triangles()) &&
           VerifyOffset(verifier, VT_TEXTS) &&
           verifier.VerifyVector(texts()) &&
           verifier.VerifyVectorOfTables(texts()) &&
           VerifyOffset(verifier, VT_SPHERES) &&
           verifier.VerifyVector(spheres()) &&
           verifier.VerifyVectorOfTables(spheres()) &&
           VerifyOffset(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           VerifyOffset(verifier, VT_CONES) &&
           verifier.VerifyVector(cones()) &&
           verifier.VerifyVectorOfTables(cones()) &&
           VerifyOffset(verifier, VT_BOXOUTLINES) &&
           verifier.VerifyVector(boxOutlines()) &&
           verifier.VerifyVectorOfTables(boxOutlines()) &&
           VerifyOffset(verifier, VT_PYRAMIDS) &&
           verifier.VerifyVector(pyramids()) &&
           verifier.VerifyVectorOfTables(pyramids()) &&
           VerifyOffset(verifier, VT_ARCS) &&
           verifier.VerifyVector(arcs()) &&
           verifier.VerifyVectorOfTables(arcs()) &&
           VerifyOffset(verifier, VT_ELLIPSES) &&
           verifier.VerifyVector(ellipses()) &&
           verifier.VerifyVectorOfTables(ellipses()) &&
           verifier.EndTable();
  }
  PrimitiveListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PrimitiveListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PrimitiveList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PrimitiveListBuilder {
  typedef PrimitiveList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_circles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Circle>>> circles) {
    fbb_.AddOffset(PrimitiveList::VT_CIRCLES, circles);
  }
  void add_rectangles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Rectangle>>> rectangles) {
    fbb_.AddOffset(PrimitiveList::VT_RECTANGLES, rectangles);
  }
  void add_triangles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Triangle>>> triangles) {
    fbb_.AddOffset(PrimitiveList::VT_TRIANGLES, triangles);
  }
  void add_texts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Text>>> texts) {
    fbb_.AddOffset(PrimitiveList::VT_TEXTS, texts);
  }
  void add_spheres(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Sphere>>> spheres) {
    fbb_.AddOffset(PrimitiveList::VT_SPHERES, spheres);
  }
  void add_lines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Line>>> lines) {
    fbb_.AddOffset(PrimitiveList::VT_LINES, lines);
  }
  void add_cones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Cone>>> cones) {
    fbb_.AddOffset(PrimitiveList::VT_CONES, cones);
  }
  void add_boxOutlines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::BoxOutline>>> boxOutlines) {
    fbb_.AddOffset(PrimitiveList::VT_BOXOUTLINES, boxOutlines);
  }
  void add_pyramids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Pyramid>>> pyramids) {
    fbb_.AddOffset(PrimitiveList::VT_PYRAMIDS, pyramids);
  }
  void add_arcs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Arc>>> arcs) {
    fbb_.AddOffset(PrimitiveList::VT_ARCS, arcs);
  }
  void add_ellipses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Ellipse>>> ellipses) {
    fbb_.AddOffset(PrimitiveList::VT_ELLIPSES, ellipses);
  }
  explicit PrimitiveListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PrimitiveList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PrimitiveList>(end);
    return o;
  }
};

inline flatbuffers::Offset<PrimitiveList> CreatePrimitiveList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Circle>>> circles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Rectangle>>> rectangles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Triangle>>> triangles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Text>>> texts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Sphere>>> spheres = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Line>>> lines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Cone>>> cones = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::BoxOutline>>> boxOutlines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Pyramid>>> pyramids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Arc>>> arcs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::Ellipse>>> ellipses = 0) {
  PrimitiveListBuilder builder_(_fbb);
  builder_.add_ellipses(ellipses);
  builder_.add_arcs(arcs);
  builder_.add_pyramids(pyramids);
  builder_.add_boxOutlines(boxOutlines);
  builder_.add_cones(cones);
  builder_.add_lines(lines);
  builder_.add_spheres(spheres);
  builder_.add_texts(texts);
  builder_.add_triangles(triangles);
  builder_.add_rectangles(rectangles);
  builder_.add_circles(circles);
  return builder_.Finish();
}

inline flatbuffers::Offset<PrimitiveList> CreatePrimitiveListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GuiSchema::Circle>> *circles = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Rectangle>> *rectangles = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Triangle>> *triangles = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Text>> *texts = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Sphere>> *spheres = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Line>> *lines = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Cone>> *cones = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::BoxOutline>> *boxOutlines = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Pyramid>> *pyramids = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Arc>> *arcs = nullptr,
    const std::vector<flatbuffers::Offset<GuiSchema::Ellipse>> *ellipses = nullptr) {
  auto circles__ = circles ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Circle>>(*circles) : 0;
  auto rectangles__ = rectangles ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Rectangle>>(*rectangles) : 0;
  auto triangles__ = triangles ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Triangle>>(*triangles) : 0;
  auto texts__ = texts ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Text>>(*texts) : 0;
  auto spheres__ = spheres ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Sphere>>(*spheres) : 0;
  auto lines__ = lines ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Line>>(*lines) : 0;
  auto cones__ = cones ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Cone>>(*cones) : 0;
  auto boxOutlines__ = boxOutlines ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::BoxOutline>>(*boxOutlines) : 0;
  auto pyramids__ = pyramids ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Pyramid>>(*pyramids) : 0;
  auto arcs__ = arcs ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Arc>>(*arcs) : 0;
  auto ellipses__ = ellipses ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Ellipse>>(*ellipses) : 0;
  return GuiSchema::CreatePrimitiveList(
      _fbb,
      circles__,
      rectangles__,
      triangles__,
      texts__,
      spheres__,
      lines__,
      cones__,
      boxOutlines__,
      pyramids__,
      arcs__,
      ellipses__);
}

flatbuffers::Offset<PrimitiveList> CreatePrimitiveList(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PrimitiveBasicT *PrimitiveBasic::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PrimitiveBasicT>(new PrimitiveBasicT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PrimitiveBasic::UnPackTo(PrimitiveBasicT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = id(); _o->id = _e; }
  { auto _e = color(); if (_e) _o->color = _e->str(); }
  { auto _e = opacity(); _o->opacity = _e; }
}

inline flatbuffers::Offset<PrimitiveBasic> PrimitiveBasic::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveBasicT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePrimitiveBasic(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PrimitiveBasic> CreatePrimitiveBasic(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveBasicT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PrimitiveBasicT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _id = _o->id;
  auto _color = _o->color.empty() ? 0 : _fbb.CreateString(_o->color);
  auto _opacity = _o->opacity;
  return GuiSchema::CreatePrimitiveBasic(
      _fbb,
      _type,
      _id,
      _color,
      _opacity);
}

inline SphereT::SphereT(const SphereT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        scale((o.scale) ? new GuiSchema::XYZ(*o.scale) : nullptr),
        rotation((o.rotation) ? new GuiSchema::XYZ(*o.rotation) : nullptr),
        radius(o.radius) {
}

inline SphereT &SphereT::operator=(SphereT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(scale, o.scale);
  std::swap(rotation, o.rotation);
  std::swap(radius, o.radius);
  return *this;
}

inline SphereT *Sphere::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SphereT>(new SphereT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sphere::UnPackTo(SphereT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = radius(); _o->radius = _e; }
}

inline flatbuffers::Offset<Sphere> Sphere::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SphereT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSphere(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sphere> CreateSphere(flatbuffers::FlatBufferBuilder &_fbb, const SphereT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SphereT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _radius = _o->radius;
  return GuiSchema::CreateSphere(
      _fbb,
      _basicInfo,
      _centerPoint,
      _scale,
      _rotation,
      _radius);
}

inline CircleT::CircleT(const CircleT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        scale((o.scale) ? new GuiSchema::XYZ(*o.scale) : nullptr),
        rotation((o.rotation) ? new GuiSchema::XYZ(*o.rotation) : nullptr),
        radius(o.radius) {
}

inline CircleT &CircleT::operator=(CircleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(scale, o.scale);
  std::swap(rotation, o.rotation);
  std::swap(radius, o.radius);
  return *this;
}

inline CircleT *Circle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CircleT>(new CircleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Circle::UnPackTo(CircleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = radius(); _o->radius = _e; }
}

inline flatbuffers::Offset<Circle> Circle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CircleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCircle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Circle> CreateCircle(flatbuffers::FlatBufferBuilder &_fbb, const CircleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CircleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _radius = _o->radius;
  return GuiSchema::CreateCircle(
      _fbb,
      _basicInfo,
      _centerPoint,
      _scale,
      _rotation,
      _radius);
}

inline RectangleT::RectangleT(const RectangleT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        scale((o.scale) ? new GuiSchema::XYZ(*o.scale) : nullptr),
        rotation((o.rotation) ? new GuiSchema::XYZ(*o.rotation) : nullptr),
        filled(o.filled),
        dashed(o.dashed),
        lineWidth(o.lineWidth) {
}

inline RectangleT &RectangleT::operator=(RectangleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(scale, o.scale);
  std::swap(rotation, o.rotation);
  std::swap(filled, o.filled);
  std::swap(dashed, o.dashed);
  std::swap(lineWidth, o.lineWidth);
  return *this;
}

inline RectangleT *Rectangle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RectangleT>(new RectangleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Rectangle::UnPackTo(RectangleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = filled(); _o->filled = _e; }
  { auto _e = dashed(); _o->dashed = _e; }
  { auto _e = lineWidth(); _o->lineWidth = _e; }
}

inline flatbuffers::Offset<Rectangle> Rectangle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RectangleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRectangle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Rectangle> CreateRectangle(flatbuffers::FlatBufferBuilder &_fbb, const RectangleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RectangleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _filled = _o->filled;
  auto _dashed = _o->dashed;
  auto _lineWidth = _o->lineWidth;
  return GuiSchema::CreateRectangle(
      _fbb,
      _basicInfo,
      _centerPoint,
      _scale,
      _rotation,
      _filled,
      _dashed,
      _lineWidth);
}

inline TriangleT::TriangleT(const TriangleT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        scale((o.scale) ? new GuiSchema::XYZ(*o.scale) : nullptr),
        rotation((o.rotation) ? new GuiSchema::XYZ(*o.rotation) : nullptr),
        lineWidth(o.lineWidth) {
}

inline TriangleT &TriangleT::operator=(TriangleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(scale, o.scale);
  std::swap(rotation, o.rotation);
  std::swap(lineWidth, o.lineWidth);
  return *this;
}

inline TriangleT *Triangle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TriangleT>(new TriangleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Triangle::UnPackTo(TriangleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = lineWidth(); _o->lineWidth = _e; }
}

inline flatbuffers::Offset<Triangle> Triangle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TriangleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTriangle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Triangle> CreateTriangle(flatbuffers::FlatBufferBuilder &_fbb, const TriangleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TriangleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _lineWidth = _o->lineWidth;
  return GuiSchema::CreateTriangle(
      _fbb,
      _basicInfo,
      _centerPoint,
      _scale,
      _rotation,
      _lineWidth);
}

inline LineT::LineT(const LineT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        points(o.points),
        lineWidth(o.lineWidth) {
}

inline LineT &LineT::operator=(LineT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(points, o.points);
  std::swap(lineWidth, o.lineWidth);
  return *this;
}

inline LineT *Line::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LineT>(new LineT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Line::UnPackTo(LineT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = *_e->Get(_i); } } }
  { auto _e = lineWidth(); _o->lineWidth = _e; }
}

inline flatbuffers::Offset<Line> Line::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LineT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLine(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Line> CreateLine(flatbuffers::FlatBufferBuilder &_fbb, const LineT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LineT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _points = _o->points.size() ? _fbb.CreateVectorOfStructs(_o->points) : 0;
  auto _lineWidth = _o->lineWidth;
  return GuiSchema::CreateLine(
      _fbb,
      _basicInfo,
      _points,
      _lineWidth);
}

inline ConeT::ConeT(const ConeT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        scale((o.scale) ? new GuiSchema::XYZ(*o.scale) : nullptr),
        rotation((o.rotation) ? new GuiSchema::XYZ(*o.rotation) : nullptr),
        height(o.height),
        radius(o.radius) {
}

inline ConeT &ConeT::operator=(ConeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(scale, o.scale);
  std::swap(rotation, o.rotation);
  std::swap(height, o.height);
  std::swap(radius, o.radius);
  return *this;
}

inline ConeT *Cone::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConeT>(new ConeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Cone::UnPackTo(ConeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = height(); _o->height = _e; }
  { auto _e = radius(); _o->radius = _e; }
}

inline flatbuffers::Offset<Cone> Cone::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCone(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cone> CreateCone(flatbuffers::FlatBufferBuilder &_fbb, const ConeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _height = _o->height;
  auto _radius = _o->radius;
  return GuiSchema::CreateCone(
      _fbb,
      _basicInfo,
      _centerPoint,
      _scale,
      _rotation,
      _height,
      _radius);
}

inline PyramidT::PyramidT(const PyramidT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        scale((o.scale) ? new GuiSchema::XYZ(*o.scale) : nullptr),
        rotation((o.rotation) ? new GuiSchema::XYZ(*o.rotation) : nullptr),
        height(o.height),
        radius(o.radius) {
}

inline PyramidT &PyramidT::operator=(PyramidT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(scale, o.scale);
  std::swap(rotation, o.rotation);
  std::swap(height, o.height);
  std::swap(radius, o.radius);
  return *this;
}

inline PyramidT *Pyramid::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PyramidT>(new PyramidT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pyramid::UnPackTo(PyramidT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = height(); _o->height = _e; }
  { auto _e = radius(); _o->radius = _e; }
}

inline flatbuffers::Offset<Pyramid> Pyramid::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PyramidT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePyramid(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pyramid> CreatePyramid(flatbuffers::FlatBufferBuilder &_fbb, const PyramidT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PyramidT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _height = _o->height;
  auto _radius = _o->radius;
  return GuiSchema::CreatePyramid(
      _fbb,
      _basicInfo,
      _centerPoint,
      _scale,
      _rotation,
      _height,
      _radius);
}

inline TextT::TextT(const TextT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        text(o.text),
        fontSize(o.fontSize) {
}

inline TextT &TextT::operator=(TextT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(text, o.text);
  std::swap(fontSize, o.fontSize);
  return *this;
}

inline TextT *Text::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TextT>(new TextT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Text::UnPackTo(TextT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = text(); if (_e) _o->text = _e->str(); }
  { auto _e = fontSize(); _o->fontSize = _e; }
}

inline flatbuffers::Offset<Text> Text::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateText(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Text> CreateText(flatbuffers::FlatBufferBuilder &_fbb, const TextT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TextT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
  auto _fontSize = _o->fontSize;
  return GuiSchema::CreateText(
      _fbb,
      _basicInfo,
      _centerPoint,
      _text,
      _fontSize);
}

inline BoxOutlineT::BoxOutlineT(const BoxOutlineT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        scale((o.scale) ? new GuiSchema::XYZ(*o.scale) : nullptr),
        rotation((o.rotation) ? new GuiSchema::XYZ(*o.rotation) : nullptr) {
}

inline BoxOutlineT &BoxOutlineT::operator=(BoxOutlineT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(scale, o.scale);
  std::swap(rotation, o.rotation);
  return *this;
}

inline BoxOutlineT *BoxOutline::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BoxOutlineT>(new BoxOutlineT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BoxOutline::UnPackTo(BoxOutlineT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = scale(); if (_e) _o->scale = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
}

inline flatbuffers::Offset<BoxOutline> BoxOutline::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoxOutlineT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoxOutline(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BoxOutline> CreateBoxOutline(flatbuffers::FlatBufferBuilder &_fbb, const BoxOutlineT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BoxOutlineT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _scale = _o->scale ? _o->scale.get() : 0;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  return GuiSchema::CreateBoxOutline(
      _fbb,
      _basicInfo,
      _centerPoint,
      _scale,
      _rotation);
}

inline ArcT::ArcT(const ArcT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        radius(o.radius),
        startAngle(o.startAngle),
        endAngle(o.endAngle),
        lineWidth(o.lineWidth) {
}

inline ArcT &ArcT::operator=(ArcT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(radius, o.radius);
  std::swap(startAngle, o.startAngle);
  std::swap(endAngle, o.endAngle);
  std::swap(lineWidth, o.lineWidth);
  return *this;
}

inline ArcT *Arc::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ArcT>(new ArcT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Arc::UnPackTo(ArcT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = radius(); _o->radius = _e; }
  { auto _e = startAngle(); _o->startAngle = _e; }
  { auto _e = endAngle(); _o->endAngle = _e; }
  { auto _e = lineWidth(); _o->lineWidth = _e; }
}

inline flatbuffers::Offset<Arc> Arc::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ArcT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateArc(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Arc> CreateArc(flatbuffers::FlatBufferBuilder &_fbb, const ArcT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ArcT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _radius = _o->radius;
  auto _startAngle = _o->startAngle;
  auto _endAngle = _o->endAngle;
  auto _lineWidth = _o->lineWidth;
  return GuiSchema::CreateArc(
      _fbb,
      _basicInfo,
      _centerPoint,
      _radius,
      _startAngle,
      _endAngle,
      _lineWidth);
}

inline EllipseT::EllipseT(const EllipseT &o)
      : basicInfo((o.basicInfo) ? new GuiSchema::PrimitiveBasicT(*o.basicInfo) : nullptr),
        centerPoint((o.centerPoint) ? new GuiSchema::XYZ(*o.centerPoint) : nullptr),
        radiusX(o.radiusX),
        radiusY(o.radiusY),
        startAngle(o.startAngle),
        endAngle(o.endAngle),
        rotation((o.rotation) ? new GuiSchema::XYZ(*o.rotation) : nullptr),
        lineWidth(o.lineWidth) {
}

inline EllipseT &EllipseT::operator=(EllipseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(basicInfo, o.basicInfo);
  std::swap(centerPoint, o.centerPoint);
  std::swap(radiusX, o.radiusX);
  std::swap(radiusY, o.radiusY);
  std::swap(startAngle, o.startAngle);
  std::swap(endAngle, o.endAngle);
  std::swap(rotation, o.rotation);
  std::swap(lineWidth, o.lineWidth);
  return *this;
}

inline EllipseT *Ellipse::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EllipseT>(new EllipseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Ellipse::UnPackTo(EllipseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = basicInfo(); if (_e) { if(_o->basicInfo) { _e->UnPackTo(_o->basicInfo.get(), _resolver); } else { _o->basicInfo = std::unique_ptr<GuiSchema::PrimitiveBasicT>(_e->UnPack(_resolver)); } } }
  { auto _e = centerPoint(); if (_e) _o->centerPoint = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = radiusX(); _o->radiusX = _e; }
  { auto _e = radiusY(); _o->radiusY = _e; }
  { auto _e = startAngle(); _o->startAngle = _e; }
  { auto _e = endAngle(); _o->endAngle = _e; }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<GuiSchema::XYZ>(new GuiSchema::XYZ(*_e)); }
  { auto _e = lineWidth(); _o->lineWidth = _e; }
}

inline flatbuffers::Offset<Ellipse> Ellipse::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EllipseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEllipse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Ellipse> CreateEllipse(flatbuffers::FlatBufferBuilder &_fbb, const EllipseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EllipseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _basicInfo = _o->basicInfo ? CreatePrimitiveBasic(_fbb, _o->basicInfo.get(), _rehasher) : 0;
  auto _centerPoint = _o->centerPoint ? _o->centerPoint.get() : 0;
  auto _radiusX = _o->radiusX;
  auto _radiusY = _o->radiusY;
  auto _startAngle = _o->startAngle;
  auto _endAngle = _o->endAngle;
  auto _rotation = _o->rotation ? _o->rotation.get() : 0;
  auto _lineWidth = _o->lineWidth;
  return GuiSchema::CreateEllipse(
      _fbb,
      _basicInfo,
      _centerPoint,
      _radiusX,
      _radiusY,
      _startAngle,
      _endAngle,
      _rotation,
      _lineWidth);
}

inline PrimitiveListT::PrimitiveListT(const PrimitiveListT &o) {
  circles.reserve(o.circles.size());
  for (const auto &v : o.circles) { circles.emplace_back((v) ? new GuiSchema::CircleT(*v) : nullptr); }
  rectangles.reserve(o.rectangles.size());
  for (const auto &v : o.rectangles) { rectangles.emplace_back((v) ? new GuiSchema::RectangleT(*v) : nullptr); }
  triangles.reserve(o.triangles.size());
  for (const auto &v : o.triangles) { triangles.emplace_back((v) ? new GuiSchema::TriangleT(*v) : nullptr); }
  texts.reserve(o.texts.size());
  for (const auto &v : o.texts) { texts.emplace_back((v) ? new GuiSchema::TextT(*v) : nullptr); }
  spheres.reserve(o.spheres.size());
  for (const auto &v : o.spheres) { spheres.emplace_back((v) ? new GuiSchema::SphereT(*v) : nullptr); }
  lines.reserve(o.lines.size());
  for (const auto &v : o.lines) { lines.emplace_back((v) ? new GuiSchema::LineT(*v) : nullptr); }
  cones.reserve(o.cones.size());
  for (const auto &v : o.cones) { cones.emplace_back((v) ? new GuiSchema::ConeT(*v) : nullptr); }
  boxOutlines.reserve(o.boxOutlines.size());
  for (const auto &v : o.boxOutlines) { boxOutlines.emplace_back((v) ? new GuiSchema::BoxOutlineT(*v) : nullptr); }
  pyramids.reserve(o.pyramids.size());
  for (const auto &v : o.pyramids) { pyramids.emplace_back((v) ? new GuiSchema::PyramidT(*v) : nullptr); }
  arcs.reserve(o.arcs.size());
  for (const auto &v : o.arcs) { arcs.emplace_back((v) ? new GuiSchema::ArcT(*v) : nullptr); }
  ellipses.reserve(o.ellipses.size());
  for (const auto &v : o.ellipses) { ellipses.emplace_back((v) ? new GuiSchema::EllipseT(*v) : nullptr); }
}

inline PrimitiveListT &PrimitiveListT::operator=(PrimitiveListT o) FLATBUFFERS_NOEXCEPT {
  std::swap(circles, o.circles);
  std::swap(rectangles, o.rectangles);
  std::swap(triangles, o.triangles);
  std::swap(texts, o.texts);
  std::swap(spheres, o.spheres);
  std::swap(lines, o.lines);
  std::swap(cones, o.cones);
  std::swap(boxOutlines, o.boxOutlines);
  std::swap(pyramids, o.pyramids);
  std::swap(arcs, o.arcs);
  std::swap(ellipses, o.ellipses);
  return *this;
}

inline PrimitiveListT *PrimitiveList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PrimitiveListT>(new PrimitiveListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PrimitiveList::UnPackTo(PrimitiveListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = circles(); if (_e) { _o->circles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->circles[_i]) { _e->Get(_i)->UnPackTo(_o->circles[_i].get(), _resolver); } else { _o->circles[_i] = std::unique_ptr<GuiSchema::CircleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = rectangles(); if (_e) { _o->rectangles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->rectangles[_i]) { _e->Get(_i)->UnPackTo(_o->rectangles[_i].get(), _resolver); } else { _o->rectangles[_i] = std::unique_ptr<GuiSchema::RectangleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = triangles(); if (_e) { _o->triangles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->triangles[_i]) { _e->Get(_i)->UnPackTo(_o->triangles[_i].get(), _resolver); } else { _o->triangles[_i] = std::unique_ptr<GuiSchema::TriangleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = texts(); if (_e) { _o->texts.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->texts[_i]) { _e->Get(_i)->UnPackTo(_o->texts[_i].get(), _resolver); } else { _o->texts[_i] = std::unique_ptr<GuiSchema::TextT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = spheres(); if (_e) { _o->spheres.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->spheres[_i]) { _e->Get(_i)->UnPackTo(_o->spheres[_i].get(), _resolver); } else { _o->spheres[_i] = std::unique_ptr<GuiSchema::SphereT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = lines(); if (_e) { _o->lines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->lines[_i]) { _e->Get(_i)->UnPackTo(_o->lines[_i].get(), _resolver); } else { _o->lines[_i] = std::unique_ptr<GuiSchema::LineT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = cones(); if (_e) { _o->cones.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->cones[_i]) { _e->Get(_i)->UnPackTo(_o->cones[_i].get(), _resolver); } else { _o->cones[_i] = std::unique_ptr<GuiSchema::ConeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = boxOutlines(); if (_e) { _o->boxOutlines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->boxOutlines[_i]) { _e->Get(_i)->UnPackTo(_o->boxOutlines[_i].get(), _resolver); } else { _o->boxOutlines[_i] = std::unique_ptr<GuiSchema::BoxOutlineT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = pyramids(); if (_e) { _o->pyramids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->pyramids[_i]) { _e->Get(_i)->UnPackTo(_o->pyramids[_i].get(), _resolver); } else { _o->pyramids[_i] = std::unique_ptr<GuiSchema::PyramidT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = arcs(); if (_e) { _o->arcs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->arcs[_i]) { _e->Get(_i)->UnPackTo(_o->arcs[_i].get(), _resolver); } else { _o->arcs[_i] = std::unique_ptr<GuiSchema::ArcT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = ellipses(); if (_e) { _o->ellipses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->ellipses[_i]) { _e->Get(_i)->UnPackTo(_o->ellipses[_i].get(), _resolver); } else { _o->ellipses[_i] = std::unique_ptr<GuiSchema::EllipseT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<PrimitiveList> PrimitiveList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePrimitiveList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PrimitiveList> CreatePrimitiveList(flatbuffers::FlatBufferBuilder &_fbb, const PrimitiveListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PrimitiveListT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _circles = _o->circles.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Circle>> (_o->circles.size(), [](size_t i, _VectorArgs *__va) { return CreateCircle(*__va->__fbb, __va->__o->circles[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _rectangles = _o->rectangles.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Rectangle>> (_o->rectangles.size(), [](size_t i, _VectorArgs *__va) { return CreateRectangle(*__va->__fbb, __va->__o->rectangles[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _triangles = _o->triangles.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Triangle>> (_o->triangles.size(), [](size_t i, _VectorArgs *__va) { return CreateTriangle(*__va->__fbb, __va->__o->triangles[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _texts = _o->texts.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Text>> (_o->texts.size(), [](size_t i, _VectorArgs *__va) { return CreateText(*__va->__fbb, __va->__o->texts[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _spheres = _o->spheres.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Sphere>> (_o->spheres.size(), [](size_t i, _VectorArgs *__va) { return CreateSphere(*__va->__fbb, __va->__o->spheres[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _lines = _o->lines.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Line>> (_o->lines.size(), [](size_t i, _VectorArgs *__va) { return CreateLine(*__va->__fbb, __va->__o->lines[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _cones = _o->cones.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Cone>> (_o->cones.size(), [](size_t i, _VectorArgs *__va) { return CreateCone(*__va->__fbb, __va->__o->cones[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _boxOutlines = _o->boxOutlines.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::BoxOutline>> (_o->boxOutlines.size(), [](size_t i, _VectorArgs *__va) { return CreateBoxOutline(*__va->__fbb, __va->__o->boxOutlines[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _pyramids = _o->pyramids.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Pyramid>> (_o->pyramids.size(), [](size_t i, _VectorArgs *__va) { return CreatePyramid(*__va->__fbb, __va->__o->pyramids[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _arcs = _o->arcs.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Arc>> (_o->arcs.size(), [](size_t i, _VectorArgs *__va) { return CreateArc(*__va->__fbb, __va->__o->arcs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _ellipses = _o->ellipses.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::Ellipse>> (_o->ellipses.size(), [](size_t i, _VectorArgs *__va) { return CreateEllipse(*__va->__fbb, __va->__o->ellipses[i].get(), __va->__rehasher); }, &_va ) : 0;
  return GuiSchema::CreatePrimitiveList(
      _fbb,
      _circles,
      _rectangles,
      _triangles,
      _texts,
      _spheres,
      _lines,
      _cones,
      _boxOutlines,
      _pyramids,
      _arcs,
      _ellipses);
}

inline const GuiSchema::PrimitiveList *GetPrimitiveList(const void *buf) {
  return flatbuffers::GetRoot<GuiSchema::PrimitiveList>(buf);
}

inline const GuiSchema::PrimitiveList *GetSizePrefixedPrimitiveList(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<GuiSchema::PrimitiveList>(buf);
}

inline const char *PrimitiveListIdentifier() {
  return "PR01";
}

inline bool PrimitiveListBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, PrimitiveListIdentifier());
}

inline bool SizePrefixedPrimitiveListBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, PrimitiveListIdentifier(), true);
}

inline bool VerifyPrimitiveListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GuiSchema::PrimitiveList>(PrimitiveListIdentifier());
}

inline bool VerifySizePrefixedPrimitiveListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GuiSchema::PrimitiveList>(PrimitiveListIdentifier());
}

inline void FinishPrimitiveListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveList> root) {
  fbb.Finish(root, PrimitiveListIdentifier());
}

inline void FinishSizePrefixedPrimitiveListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GuiSchema::PrimitiveList> root) {
  fbb.FinishSizePrefixed(root, PrimitiveListIdentifier());
}

inline std::unique_ptr<GuiSchema::PrimitiveListT> UnPackPrimitiveList(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GuiSchema::PrimitiveListT>(GetPrimitiveList(buf)->UnPack(res));
}

inline std::unique_ptr<GuiSchema::PrimitiveListT> UnPackSizePrefixedPrimitiveList(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GuiSchema::PrimitiveListT>(GetSizePrefixedPrimitiveList(buf)->UnPack(res));
}

}  // namespace GuiSchema

#endif  // FLATBUFFERS_GENERATED_PRIMITIVE_GUISCHEMA_H_
