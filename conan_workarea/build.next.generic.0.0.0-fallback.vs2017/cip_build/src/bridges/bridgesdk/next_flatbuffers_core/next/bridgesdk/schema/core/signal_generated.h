// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SIGNAL_CORE_H_
#define FLATBUFFERS_GENERATED_SIGNAL_CORE_H_

#include "flatbuffers/flatbuffers.h"

#include "next/bridgesdk/schema/core/types_generated.h"

namespace Core {

struct Signal;
struct SignalBuilder;
struct SignalT;

struct SignalInfo;
struct SignalInfoBuilder;
struct SignalInfoT;

struct SignalList;
struct SignalListBuilder;
struct SignalListT;

struct SignalRequest;
struct SignalRequestBuilder;
struct SignalRequestT;

struct SignalT : public flatbuffers::NativeTable {
  typedef Signal TableType;
  uint64_t hash = 0;
  Core::AnyValueUnion value{};
};

struct Signal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalT NativeTableType;
  typedef SignalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASH = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  uint64_t hash() const {
    return GetField<uint64_t>(VT_HASH, 0);
  }
  Core::AnyValue value_type() const {
    return static_cast<Core::AnyValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Core::TypeUInt8 *value_as_TypeUInt8() const {
    return value_type() == Core::AnyValue::TypeUInt8 ? static_cast<const Core::TypeUInt8 *>(value()) : nullptr;
  }
  const Core::TypeUInt16 *value_as_TypeUInt16() const {
    return value_type() == Core::AnyValue::TypeUInt16 ? static_cast<const Core::TypeUInt16 *>(value()) : nullptr;
  }
  const Core::TypeUInt32 *value_as_TypeUInt32() const {
    return value_type() == Core::AnyValue::TypeUInt32 ? static_cast<const Core::TypeUInt32 *>(value()) : nullptr;
  }
  const Core::TypeUInt64 *value_as_TypeUInt64() const {
    return value_type() == Core::AnyValue::TypeUInt64 ? static_cast<const Core::TypeUInt64 *>(value()) : nullptr;
  }
  const Core::TypeInt8 *value_as_TypeInt8() const {
    return value_type() == Core::AnyValue::TypeInt8 ? static_cast<const Core::TypeInt8 *>(value()) : nullptr;
  }
  const Core::TypeInt16 *value_as_TypeInt16() const {
    return value_type() == Core::AnyValue::TypeInt16 ? static_cast<const Core::TypeInt16 *>(value()) : nullptr;
  }
  const Core::TypeInt32 *value_as_TypeInt32() const {
    return value_type() == Core::AnyValue::TypeInt32 ? static_cast<const Core::TypeInt32 *>(value()) : nullptr;
  }
  const Core::TypeInt64 *value_as_TypeInt64() const {
    return value_type() == Core::AnyValue::TypeInt64 ? static_cast<const Core::TypeInt64 *>(value()) : nullptr;
  }
  const Core::TypeFloat *value_as_TypeFloat() const {
    return value_type() == Core::AnyValue::TypeFloat ? static_cast<const Core::TypeFloat *>(value()) : nullptr;
  }
  const Core::TypeBool *value_as_TypeBool() const {
    return value_type() == Core::AnyValue::TypeBool ? static_cast<const Core::TypeBool *>(value()) : nullptr;
  }
  const Core::TypeDouble *value_as_TypeDouble() const {
    return value_type() == Core::AnyValue::TypeDouble ? static_cast<const Core::TypeDouble *>(value()) : nullptr;
  }
  const Core::TypeChar *value_as_TypeChar() const {
    return value_type() == Core::AnyValue::TypeChar ? static_cast<const Core::TypeChar *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_HASH, 8) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyAnyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  SignalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Signal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Core::TypeUInt8 *Signal::value_as<Core::TypeUInt8>() const {
  return value_as_TypeUInt8();
}

template<> inline const Core::TypeUInt16 *Signal::value_as<Core::TypeUInt16>() const {
  return value_as_TypeUInt16();
}

template<> inline const Core::TypeUInt32 *Signal::value_as<Core::TypeUInt32>() const {
  return value_as_TypeUInt32();
}

template<> inline const Core::TypeUInt64 *Signal::value_as<Core::TypeUInt64>() const {
  return value_as_TypeUInt64();
}

template<> inline const Core::TypeInt8 *Signal::value_as<Core::TypeInt8>() const {
  return value_as_TypeInt8();
}

template<> inline const Core::TypeInt16 *Signal::value_as<Core::TypeInt16>() const {
  return value_as_TypeInt16();
}

template<> inline const Core::TypeInt32 *Signal::value_as<Core::TypeInt32>() const {
  return value_as_TypeInt32();
}

template<> inline const Core::TypeInt64 *Signal::value_as<Core::TypeInt64>() const {
  return value_as_TypeInt64();
}

template<> inline const Core::TypeFloat *Signal::value_as<Core::TypeFloat>() const {
  return value_as_TypeFloat();
}

template<> inline const Core::TypeBool *Signal::value_as<Core::TypeBool>() const {
  return value_as_TypeBool();
}

template<> inline const Core::TypeDouble *Signal::value_as<Core::TypeDouble>() const {
  return value_as_TypeDouble();
}

template<> inline const Core::TypeChar *Signal::value_as<Core::TypeChar>() const {
  return value_as_TypeChar();
}

struct SignalBuilder {
  typedef Signal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hash(uint64_t hash) {
    fbb_.AddElement<uint64_t>(Signal::VT_HASH, hash, 0);
  }
  void add_value_type(Core::AnyValue value_type) {
    fbb_.AddElement<uint8_t>(Signal::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Signal::VT_VALUE, value);
  }
  explicit SignalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Signal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Signal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Signal> CreateSignal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t hash = 0,
    Core::AnyValue value_type = Core::AnyValue::NONE,
    flatbuffers::Offset<void> value = 0) {
  SignalBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

flatbuffers::Offset<Signal> CreateSignal(flatbuffers::FlatBufferBuilder &_fbb, const SignalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignalInfoT : public flatbuffers::NativeTable {
  typedef SignalInfo TableType;
  std::string signal_name{};
  uint64_t hash = 0;
};

struct SignalInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalInfoT NativeTableType;
  typedef SignalInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIGNAL_NAME = 4,
    VT_HASH = 6
  };
  const flatbuffers::String *signal_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNAL_NAME);
  }
  uint64_t hash() const {
    return GetField<uint64_t>(VT_HASH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SIGNAL_NAME) &&
           verifier.VerifyString(signal_name()) &&
           VerifyField<uint64_t>(verifier, VT_HASH, 8) &&
           verifier.EndTable();
  }
  SignalInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignalInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignalInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignalInfoBuilder {
  typedef SignalInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_signal_name(flatbuffers::Offset<flatbuffers::String> signal_name) {
    fbb_.AddOffset(SignalInfo::VT_SIGNAL_NAME, signal_name);
  }
  void add_hash(uint64_t hash) {
    fbb_.AddElement<uint64_t>(SignalInfo::VT_HASH, hash, 0);
  }
  explicit SignalInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalInfo> CreateSignalInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> signal_name = 0,
    uint64_t hash = 0) {
  SignalInfoBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_signal_name(signal_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalInfo> CreateSignalInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *signal_name = nullptr,
    uint64_t hash = 0) {
  auto signal_name__ = signal_name ? _fbb.CreateString(signal_name) : 0;
  return Core::CreateSignalInfo(
      _fbb,
      signal_name__,
      hash);
}

flatbuffers::Offset<SignalInfo> CreateSignalInfo(flatbuffers::FlatBufferBuilder &_fbb, const SignalInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignalListT : public flatbuffers::NativeTable {
  typedef SignalList TableType;
  std::vector<std::unique_ptr<Core::SignalInfoT>> new_signal_info{};
  std::vector<std::unique_ptr<Core::SignalT>> signals{};
  SignalListT() = default;
  SignalListT(const SignalListT &o);
  SignalListT(SignalListT&&) FLATBUFFERS_NOEXCEPT = default;
  SignalListT &operator=(SignalListT o) FLATBUFFERS_NOEXCEPT;
};

struct SignalList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalListT NativeTableType;
  typedef SignalListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_SIGNAL_INFO = 4,
    VT_SIGNALS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Core::SignalInfo>> *new_signal_info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Core::SignalInfo>> *>(VT_NEW_SIGNAL_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Core::Signal>> *signals() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Core::Signal>> *>(VT_SIGNALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_SIGNAL_INFO) &&
           verifier.VerifyVector(new_signal_info()) &&
           verifier.VerifyVectorOfTables(new_signal_info()) &&
           VerifyOffset(verifier, VT_SIGNALS) &&
           verifier.VerifyVector(signals()) &&
           verifier.VerifyVectorOfTables(signals()) &&
           verifier.EndTable();
  }
  SignalListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignalListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignalList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignalListBuilder {
  typedef SignalList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_signal_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Core::SignalInfo>>> new_signal_info) {
    fbb_.AddOffset(SignalList::VT_NEW_SIGNAL_INFO, new_signal_info);
  }
  void add_signals(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Core::Signal>>> signals) {
    fbb_.AddOffset(SignalList::VT_SIGNALS, signals);
  }
  explicit SignalListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalList>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalList> CreateSignalList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Core::SignalInfo>>> new_signal_info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Core::Signal>>> signals = 0) {
  SignalListBuilder builder_(_fbb);
  builder_.add_signals(signals);
  builder_.add_new_signal_info(new_signal_info);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalList> CreateSignalListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Core::SignalInfo>> *new_signal_info = nullptr,
    const std::vector<flatbuffers::Offset<Core::Signal>> *signals = nullptr) {
  auto new_signal_info__ = new_signal_info ? _fbb.CreateVector<flatbuffers::Offset<Core::SignalInfo>>(*new_signal_info) : 0;
  auto signals__ = signals ? _fbb.CreateVector<flatbuffers::Offset<Core::Signal>>(*signals) : 0;
  return Core::CreateSignalList(
      _fbb,
      new_signal_info__,
      signals__);
}

flatbuffers::Offset<SignalList> CreateSignalList(flatbuffers::FlatBufferBuilder &_fbb, const SignalListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignalRequestT : public flatbuffers::NativeTable {
  typedef SignalRequest TableType;
  std::vector<std::string> signal_name{};
};

struct SignalRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalRequestT NativeTableType;
  typedef SignalRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIGNAL_NAME = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *signal_name() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SIGNAL_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SIGNAL_NAME) &&
           verifier.VerifyVector(signal_name()) &&
           verifier.VerifyVectorOfStrings(signal_name()) &&
           verifier.EndTable();
  }
  SignalRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignalRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignalRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignalRequestBuilder {
  typedef SignalRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_signal_name(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> signal_name) {
    fbb_.AddOffset(SignalRequest::VT_SIGNAL_NAME, signal_name);
  }
  explicit SignalRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalRequest> CreateSignalRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> signal_name = 0) {
  SignalRequestBuilder builder_(_fbb);
  builder_.add_signal_name(signal_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalRequest> CreateSignalRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *signal_name = nullptr) {
  auto signal_name__ = signal_name ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*signal_name) : 0;
  return Core::CreateSignalRequest(
      _fbb,
      signal_name__);
}

flatbuffers::Offset<SignalRequest> CreateSignalRequest(flatbuffers::FlatBufferBuilder &_fbb, const SignalRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SignalT *Signal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignalT>(new SignalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Signal::UnPackTo(SignalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hash(); _o->hash = _e; }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = Core::AnyValueUnion::UnPack(_e, value_type(), _resolver); }
}

inline flatbuffers::Offset<Signal> Signal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Signal> CreateSignal(flatbuffers::FlatBufferBuilder &_fbb, const SignalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hash = _o->hash;
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return Core::CreateSignal(
      _fbb,
      _hash,
      _value_type,
      _value);
}

inline SignalInfoT *SignalInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignalInfoT>(new SignalInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SignalInfo::UnPackTo(SignalInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = signal_name(); if (_e) _o->signal_name = _e->str(); }
  { auto _e = hash(); _o->hash = _e; }
}

inline flatbuffers::Offset<SignalInfo> SignalInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignalInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignalInfo> CreateSignalInfo(flatbuffers::FlatBufferBuilder &_fbb, const SignalInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignalInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _signal_name = _o->signal_name.empty() ? 0 : _fbb.CreateString(_o->signal_name);
  auto _hash = _o->hash;
  return Core::CreateSignalInfo(
      _fbb,
      _signal_name,
      _hash);
}

inline SignalListT::SignalListT(const SignalListT &o) {
  new_signal_info.reserve(o.new_signal_info.size());
  for (const auto &v : o.new_signal_info) { new_signal_info.emplace_back((v) ? new Core::SignalInfoT(*v) : nullptr); }
  signals.reserve(o.signals.size());
  for (const auto &v : o.signals) { signals.emplace_back((v) ? new Core::SignalT(*v) : nullptr); }
}

inline SignalListT &SignalListT::operator=(SignalListT o) FLATBUFFERS_NOEXCEPT {
  std::swap(new_signal_info, o.new_signal_info);
  std::swap(signals, o.signals);
  return *this;
}

inline SignalListT *SignalList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignalListT>(new SignalListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SignalList::UnPackTo(SignalListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = new_signal_info(); if (_e) { _o->new_signal_info.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->new_signal_info[_i]) { _e->Get(_i)->UnPackTo(_o->new_signal_info[_i].get(), _resolver); } else { _o->new_signal_info[_i] = std::unique_ptr<Core::SignalInfoT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = signals(); if (_e) { _o->signals.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->signals[_i]) { _e->Get(_i)->UnPackTo(_o->signals[_i].get(), _resolver); } else { _o->signals[_i] = std::unique_ptr<Core::SignalT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<SignalList> SignalList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignalList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignalList> CreateSignalList(flatbuffers::FlatBufferBuilder &_fbb, const SignalListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignalListT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _new_signal_info = _o->new_signal_info.size() ? _fbb.CreateVector<flatbuffers::Offset<Core::SignalInfo>> (_o->new_signal_info.size(), [](size_t i, _VectorArgs *__va) { return CreateSignalInfo(*__va->__fbb, __va->__o->new_signal_info[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _signals = _o->signals.size() ? _fbb.CreateVector<flatbuffers::Offset<Core::Signal>> (_o->signals.size(), [](size_t i, _VectorArgs *__va) { return CreateSignal(*__va->__fbb, __va->__o->signals[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Core::CreateSignalList(
      _fbb,
      _new_signal_info,
      _signals);
}

inline SignalRequestT *SignalRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignalRequestT>(new SignalRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SignalRequest::UnPackTo(SignalRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = signal_name(); if (_e) { _o->signal_name.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->signal_name[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<SignalRequest> SignalRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignalRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignalRequest> CreateSignalRequest(flatbuffers::FlatBufferBuilder &_fbb, const SignalRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignalRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _signal_name = _o->signal_name.size() ? _fbb.CreateVectorOfStrings(_o->signal_name) : 0;
  return Core::CreateSignalRequest(
      _fbb,
      _signal_name);
}

inline const Core::SignalList *GetSignalList(const void *buf) {
  return flatbuffers::GetRoot<Core::SignalList>(buf);
}

inline const Core::SignalList *GetSizePrefixedSignalList(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Core::SignalList>(buf);
}

inline bool VerifySignalListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Core::SignalList>(nullptr);
}

inline bool VerifySizePrefixedSignalListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Core::SignalList>(nullptr);
}

inline void FinishSignalListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Core::SignalList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSignalListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Core::SignalList> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Core::SignalListT> UnPackSignalList(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Core::SignalListT>(GetSignalList(buf)->UnPack(res));
}

inline std::unique_ptr<Core::SignalListT> UnPackSizePrefixedSignalList(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Core::SignalListT>(GetSizePrefixedSignalList(buf)->UnPack(res));
}

}  // namespace Core

#endif  // FLATBUFFERS_GENERATED_SIGNAL_CORE_H_
