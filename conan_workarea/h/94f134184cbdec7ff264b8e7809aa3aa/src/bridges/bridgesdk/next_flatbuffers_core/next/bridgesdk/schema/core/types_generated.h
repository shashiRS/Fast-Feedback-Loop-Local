// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TYPES_CORE_H_
#define FLATBUFFERS_GENERATED_TYPES_CORE_H_

#include "flatbuffers/flatbuffers.h"

namespace Core {

struct TypeUInt8;
struct TypeUInt8Builder;
struct TypeUInt8T;

struct TypeUInt16;
struct TypeUInt16Builder;
struct TypeUInt16T;

struct TypeUInt32;
struct TypeUInt32Builder;
struct TypeUInt32T;

struct TypeUInt64;
struct TypeUInt64Builder;
struct TypeUInt64T;

struct TypeInt8;
struct TypeInt8Builder;
struct TypeInt8T;

struct TypeInt16;
struct TypeInt16Builder;
struct TypeInt16T;

struct TypeInt32;
struct TypeInt32Builder;
struct TypeInt32T;

struct TypeInt64;
struct TypeInt64Builder;
struct TypeInt64T;

struct TypeFloat;
struct TypeFloatBuilder;
struct TypeFloatT;

struct TypeBool;
struct TypeBoolBuilder;
struct TypeBoolT;

struct TypeDouble;
struct TypeDoubleBuilder;
struct TypeDoubleT;

struct TypeChar;
struct TypeCharBuilder;
struct TypeCharT;

enum class AnyValue : uint8_t {
  NONE = 0,
  TypeUInt8 = 1,
  TypeUInt16 = 2,
  TypeUInt32 = 3,
  TypeUInt64 = 4,
  TypeInt8 = 5,
  TypeInt16 = 6,
  TypeInt32 = 7,
  TypeInt64 = 8,
  TypeFloat = 9,
  TypeBool = 10,
  TypeDouble = 11,
  TypeChar = 12,
  MIN = NONE,
  MAX = TypeChar
};

inline const AnyValue (&EnumValuesAnyValue())[13] {
  static const AnyValue values[] = {
    AnyValue::NONE,
    AnyValue::TypeUInt8,
    AnyValue::TypeUInt16,
    AnyValue::TypeUInt32,
    AnyValue::TypeUInt64,
    AnyValue::TypeInt8,
    AnyValue::TypeInt16,
    AnyValue::TypeInt32,
    AnyValue::TypeInt64,
    AnyValue::TypeFloat,
    AnyValue::TypeBool,
    AnyValue::TypeDouble,
    AnyValue::TypeChar
  };
  return values;
}

inline const char * const *EnumNamesAnyValue() {
  static const char * const names[14] = {
    "NONE",
    "TypeUInt8",
    "TypeUInt16",
    "TypeUInt32",
    "TypeUInt64",
    "TypeInt8",
    "TypeInt16",
    "TypeInt32",
    "TypeInt64",
    "TypeFloat",
    "TypeBool",
    "TypeDouble",
    "TypeChar",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyValue(AnyValue e) {
  if (flatbuffers::IsOutRange(e, AnyValue::NONE, AnyValue::TypeChar)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyValue()[index];
}

template<typename T> struct AnyValueTraits {
  static const AnyValue enum_value = AnyValue::NONE;
};

template<> struct AnyValueTraits<Core::TypeUInt8> {
  static const AnyValue enum_value = AnyValue::TypeUInt8;
};

template<> struct AnyValueTraits<Core::TypeUInt16> {
  static const AnyValue enum_value = AnyValue::TypeUInt16;
};

template<> struct AnyValueTraits<Core::TypeUInt32> {
  static const AnyValue enum_value = AnyValue::TypeUInt32;
};

template<> struct AnyValueTraits<Core::TypeUInt64> {
  static const AnyValue enum_value = AnyValue::TypeUInt64;
};

template<> struct AnyValueTraits<Core::TypeInt8> {
  static const AnyValue enum_value = AnyValue::TypeInt8;
};

template<> struct AnyValueTraits<Core::TypeInt16> {
  static const AnyValue enum_value = AnyValue::TypeInt16;
};

template<> struct AnyValueTraits<Core::TypeInt32> {
  static const AnyValue enum_value = AnyValue::TypeInt32;
};

template<> struct AnyValueTraits<Core::TypeInt64> {
  static const AnyValue enum_value = AnyValue::TypeInt64;
};

template<> struct AnyValueTraits<Core::TypeFloat> {
  static const AnyValue enum_value = AnyValue::TypeFloat;
};

template<> struct AnyValueTraits<Core::TypeBool> {
  static const AnyValue enum_value = AnyValue::TypeBool;
};

template<> struct AnyValueTraits<Core::TypeDouble> {
  static const AnyValue enum_value = AnyValue::TypeDouble;
};

template<> struct AnyValueTraits<Core::TypeChar> {
  static const AnyValue enum_value = AnyValue::TypeChar;
};

template<typename T> struct AnyValueUnionTraits {
  static const AnyValue enum_value = AnyValue::NONE;
};

template<> struct AnyValueUnionTraits<Core::TypeUInt8T> {
  static const AnyValue enum_value = AnyValue::TypeUInt8;
};

template<> struct AnyValueUnionTraits<Core::TypeUInt16T> {
  static const AnyValue enum_value = AnyValue::TypeUInt16;
};

template<> struct AnyValueUnionTraits<Core::TypeUInt32T> {
  static const AnyValue enum_value = AnyValue::TypeUInt32;
};

template<> struct AnyValueUnionTraits<Core::TypeUInt64T> {
  static const AnyValue enum_value = AnyValue::TypeUInt64;
};

template<> struct AnyValueUnionTraits<Core::TypeInt8T> {
  static const AnyValue enum_value = AnyValue::TypeInt8;
};

template<> struct AnyValueUnionTraits<Core::TypeInt16T> {
  static const AnyValue enum_value = AnyValue::TypeInt16;
};

template<> struct AnyValueUnionTraits<Core::TypeInt32T> {
  static const AnyValue enum_value = AnyValue::TypeInt32;
};

template<> struct AnyValueUnionTraits<Core::TypeInt64T> {
  static const AnyValue enum_value = AnyValue::TypeInt64;
};

template<> struct AnyValueUnionTraits<Core::TypeFloatT> {
  static const AnyValue enum_value = AnyValue::TypeFloat;
};

template<> struct AnyValueUnionTraits<Core::TypeBoolT> {
  static const AnyValue enum_value = AnyValue::TypeBool;
};

template<> struct AnyValueUnionTraits<Core::TypeDoubleT> {
  static const AnyValue enum_value = AnyValue::TypeDouble;
};

template<> struct AnyValueUnionTraits<Core::TypeCharT> {
  static const AnyValue enum_value = AnyValue::TypeChar;
};

struct AnyValueUnion {
  AnyValue type;
  void *value;

  AnyValueUnion() : type(AnyValue::NONE), value(nullptr) {}
  AnyValueUnion(AnyValueUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AnyValue::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AnyValueUnion(const AnyValueUnion &);
  AnyValueUnion &operator=(const AnyValueUnion &u)
    { AnyValueUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AnyValueUnion &operator=(AnyValueUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AnyValueUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = AnyValueUnionTraits<RT>::enum_value;
    if (type != AnyValue::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, AnyValue type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Core::TypeUInt8T *AsTypeUInt8() {
    return type == AnyValue::TypeUInt8 ?
      reinterpret_cast<Core::TypeUInt8T *>(value) : nullptr;
  }
  const Core::TypeUInt8T *AsTypeUInt8() const {
    return type == AnyValue::TypeUInt8 ?
      reinterpret_cast<const Core::TypeUInt8T *>(value) : nullptr;
  }
  Core::TypeUInt16T *AsTypeUInt16() {
    return type == AnyValue::TypeUInt16 ?
      reinterpret_cast<Core::TypeUInt16T *>(value) : nullptr;
  }
  const Core::TypeUInt16T *AsTypeUInt16() const {
    return type == AnyValue::TypeUInt16 ?
      reinterpret_cast<const Core::TypeUInt16T *>(value) : nullptr;
  }
  Core::TypeUInt32T *AsTypeUInt32() {
    return type == AnyValue::TypeUInt32 ?
      reinterpret_cast<Core::TypeUInt32T *>(value) : nullptr;
  }
  const Core::TypeUInt32T *AsTypeUInt32() const {
    return type == AnyValue::TypeUInt32 ?
      reinterpret_cast<const Core::TypeUInt32T *>(value) : nullptr;
  }
  Core::TypeUInt64T *AsTypeUInt64() {
    return type == AnyValue::TypeUInt64 ?
      reinterpret_cast<Core::TypeUInt64T *>(value) : nullptr;
  }
  const Core::TypeUInt64T *AsTypeUInt64() const {
    return type == AnyValue::TypeUInt64 ?
      reinterpret_cast<const Core::TypeUInt64T *>(value) : nullptr;
  }
  Core::TypeInt8T *AsTypeInt8() {
    return type == AnyValue::TypeInt8 ?
      reinterpret_cast<Core::TypeInt8T *>(value) : nullptr;
  }
  const Core::TypeInt8T *AsTypeInt8() const {
    return type == AnyValue::TypeInt8 ?
      reinterpret_cast<const Core::TypeInt8T *>(value) : nullptr;
  }
  Core::TypeInt16T *AsTypeInt16() {
    return type == AnyValue::TypeInt16 ?
      reinterpret_cast<Core::TypeInt16T *>(value) : nullptr;
  }
  const Core::TypeInt16T *AsTypeInt16() const {
    return type == AnyValue::TypeInt16 ?
      reinterpret_cast<const Core::TypeInt16T *>(value) : nullptr;
  }
  Core::TypeInt32T *AsTypeInt32() {
    return type == AnyValue::TypeInt32 ?
      reinterpret_cast<Core::TypeInt32T *>(value) : nullptr;
  }
  const Core::TypeInt32T *AsTypeInt32() const {
    return type == AnyValue::TypeInt32 ?
      reinterpret_cast<const Core::TypeInt32T *>(value) : nullptr;
  }
  Core::TypeInt64T *AsTypeInt64() {
    return type == AnyValue::TypeInt64 ?
      reinterpret_cast<Core::TypeInt64T *>(value) : nullptr;
  }
  const Core::TypeInt64T *AsTypeInt64() const {
    return type == AnyValue::TypeInt64 ?
      reinterpret_cast<const Core::TypeInt64T *>(value) : nullptr;
  }
  Core::TypeFloatT *AsTypeFloat() {
    return type == AnyValue::TypeFloat ?
      reinterpret_cast<Core::TypeFloatT *>(value) : nullptr;
  }
  const Core::TypeFloatT *AsTypeFloat() const {
    return type == AnyValue::TypeFloat ?
      reinterpret_cast<const Core::TypeFloatT *>(value) : nullptr;
  }
  Core::TypeBoolT *AsTypeBool() {
    return type == AnyValue::TypeBool ?
      reinterpret_cast<Core::TypeBoolT *>(value) : nullptr;
  }
  const Core::TypeBoolT *AsTypeBool() const {
    return type == AnyValue::TypeBool ?
      reinterpret_cast<const Core::TypeBoolT *>(value) : nullptr;
  }
  Core::TypeDoubleT *AsTypeDouble() {
    return type == AnyValue::TypeDouble ?
      reinterpret_cast<Core::TypeDoubleT *>(value) : nullptr;
  }
  const Core::TypeDoubleT *AsTypeDouble() const {
    return type == AnyValue::TypeDouble ?
      reinterpret_cast<const Core::TypeDoubleT *>(value) : nullptr;
  }
  Core::TypeCharT *AsTypeChar() {
    return type == AnyValue::TypeChar ?
      reinterpret_cast<Core::TypeCharT *>(value) : nullptr;
  }
  const Core::TypeCharT *AsTypeChar() const {
    return type == AnyValue::TypeChar ?
      reinterpret_cast<const Core::TypeCharT *>(value) : nullptr;
  }
};

bool VerifyAnyValue(flatbuffers::Verifier &verifier, const void *obj, AnyValue type);
bool VerifyAnyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<AnyValue> *types);

struct TypeUInt8T : public flatbuffers::NativeTable {
  typedef TypeUInt8 TableType;
  uint8_t value = 0;
};

struct TypeUInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeUInt8T NativeTableType;
  typedef TypeUInt8Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
  TypeUInt8T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeUInt8T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeUInt8> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeUInt8Builder {
  typedef TypeUInt8 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(TypeUInt8::VT_VALUE, value, 0);
  }
  explicit TypeUInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeUInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeUInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeUInt8> CreateTypeUInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  TypeUInt8Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeUInt8> CreateTypeUInt8(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeUInt16T : public flatbuffers::NativeTable {
  typedef TypeUInt16 TableType;
  uint16_t value = 0;
};

struct TypeUInt16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeUInt16T NativeTableType;
  typedef TypeUInt16Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint16_t value() const {
    return GetField<uint16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
  TypeUInt16T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeUInt16T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeUInt16> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt16T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeUInt16Builder {
  typedef TypeUInt16 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint16_t value) {
    fbb_.AddElement<uint16_t>(TypeUInt16::VT_VALUE, value, 0);
  }
  explicit TypeUInt16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeUInt16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeUInt16>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeUInt16> CreateTypeUInt16(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t value = 0) {
  TypeUInt16Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeUInt16> CreateTypeUInt16(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt16T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeUInt32T : public flatbuffers::NativeTable {
  typedef TypeUInt32 TableType;
  uint32_t value = 0;
};

struct TypeUInt32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeUInt32T NativeTableType;
  typedef TypeUInt32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
  TypeUInt32T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeUInt32T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeUInt32> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt32T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeUInt32Builder {
  typedef TypeUInt32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(TypeUInt32::VT_VALUE, value, 0);
  }
  explicit TypeUInt32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeUInt32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeUInt32>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeUInt32> CreateTypeUInt32(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  TypeUInt32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeUInt32> CreateTypeUInt32(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt32T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeUInt64T : public flatbuffers::NativeTable {
  typedef TypeUInt64 TableType;
  uint64_t value = 0;
};

struct TypeUInt64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeUInt64T NativeTableType;
  typedef TypeUInt64Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
  TypeUInt64T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeUInt64T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeUInt64> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt64T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeUInt64Builder {
  typedef TypeUInt64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(TypeUInt64::VT_VALUE, value, 0);
  }
  explicit TypeUInt64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeUInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeUInt64>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeUInt64> CreateTypeUInt64(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  TypeUInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeUInt64> CreateTypeUInt64(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt64T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeInt8T : public flatbuffers::NativeTable {
  typedef TypeInt8 TableType;
  int8_t value = 0;
};

struct TypeInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeInt8T NativeTableType;
  typedef TypeInt8Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
  TypeInt8T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeInt8T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeInt8> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeInt8Builder {
  typedef TypeInt8 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(TypeInt8::VT_VALUE, value, 0);
  }
  explicit TypeInt8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeInt8>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeInt8> CreateTypeInt8(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  TypeInt8Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeInt8> CreateTypeInt8(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeInt16T : public flatbuffers::NativeTable {
  typedef TypeInt16 TableType;
  int16_t value = 0;
};

struct TypeInt16 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeInt16T NativeTableType;
  typedef TypeInt16Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE, 2) &&
           verifier.EndTable();
  }
  TypeInt16T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeInt16T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeInt16> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt16T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeInt16Builder {
  typedef TypeInt16 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(TypeInt16::VT_VALUE, value, 0);
  }
  explicit TypeInt16Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeInt16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeInt16>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeInt16> CreateTypeInt16(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  TypeInt16Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeInt16> CreateTypeInt16(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt16T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeInt32T : public flatbuffers::NativeTable {
  typedef TypeInt32 TableType;
  int32_t value = 0;
};

struct TypeInt32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeInt32T NativeTableType;
  typedef TypeInt32Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
  TypeInt32T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeInt32T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeInt32> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt32T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeInt32Builder {
  typedef TypeInt32 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(TypeInt32::VT_VALUE, value, 0);
  }
  explicit TypeInt32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeInt32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeInt32>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeInt32> CreateTypeInt32(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  TypeInt32Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeInt32> CreateTypeInt32(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt32T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeInt64T : public flatbuffers::NativeTable {
  typedef TypeInt64 TableType;
  int64_t value = 0;
};

struct TypeInt64 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeInt64T NativeTableType;
  typedef TypeInt64Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
  TypeInt64T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeInt64T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeInt64> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt64T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeInt64Builder {
  typedef TypeInt64 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(TypeInt64::VT_VALUE, value, 0);
  }
  explicit TypeInt64Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeInt64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeInt64>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeInt64> CreateTypeInt64(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  TypeInt64Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeInt64> CreateTypeInt64(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt64T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeFloatT : public flatbuffers::NativeTable {
  typedef TypeFloat TableType;
  float value = 0.0f;
};

struct TypeFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeFloatT NativeTableType;
  typedef TypeFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
  TypeFloatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeFloatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeFloat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeFloatBuilder {
  typedef TypeFloat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(TypeFloat::VT_VALUE, value, 0.0f);
  }
  explicit TypeFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeFloat> CreateTypeFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  TypeFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeFloat> CreateTypeFloat(flatbuffers::FlatBufferBuilder &_fbb, const TypeFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeBoolT : public flatbuffers::NativeTable {
  typedef TypeBool TableType;
  bool value = false;
};

struct TypeBool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeBoolT NativeTableType;
  typedef TypeBoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
  TypeBoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeBoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeBool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeBoolBuilder {
  typedef TypeBool Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(TypeBool::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit TypeBoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeBool>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeBool> CreateTypeBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  TypeBoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeBool> CreateTypeBool(flatbuffers::FlatBufferBuilder &_fbb, const TypeBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeDoubleT : public flatbuffers::NativeTable {
  typedef TypeDouble TableType;
  double value = 0.0;
};

struct TypeDouble FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeDoubleT NativeTableType;
  typedef TypeDoubleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
  TypeDoubleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeDoubleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeDouble> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeDoubleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeDoubleBuilder {
  typedef TypeDouble Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(TypeDouble::VT_VALUE, value, 0.0);
  }
  explicit TypeDoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeDouble> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeDouble>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeDouble> CreateTypeDouble(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  TypeDoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeDouble> CreateTypeDouble(flatbuffers::FlatBufferBuilder &_fbb, const TypeDoubleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeCharT : public flatbuffers::NativeTable {
  typedef TypeChar TableType;
  uint8_t value = 0;
};

struct TypeChar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeCharT NativeTableType;
  typedef TypeCharBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
  TypeCharT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeCharT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeChar> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeCharT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeCharBuilder {
  typedef TypeChar Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(TypeChar::VT_VALUE, value, 0);
  }
  explicit TypeCharBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeChar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeChar>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeChar> CreateTypeChar(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  TypeCharBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<TypeChar> CreateTypeChar(flatbuffers::FlatBufferBuilder &_fbb, const TypeCharT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TypeUInt8T *TypeUInt8::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeUInt8T>(new TypeUInt8T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeUInt8::UnPackTo(TypeUInt8T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeUInt8> TypeUInt8::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeUInt8(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeUInt8> CreateTypeUInt8(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeUInt8T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeUInt8(
      _fbb,
      _value);
}

inline TypeUInt16T *TypeUInt16::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeUInt16T>(new TypeUInt16T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeUInt16::UnPackTo(TypeUInt16T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeUInt16> TypeUInt16::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt16T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeUInt16(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeUInt16> CreateTypeUInt16(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt16T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeUInt16T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeUInt16(
      _fbb,
      _value);
}

inline TypeUInt32T *TypeUInt32::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeUInt32T>(new TypeUInt32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeUInt32::UnPackTo(TypeUInt32T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeUInt32> TypeUInt32::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt32T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeUInt32(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeUInt32> CreateTypeUInt32(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt32T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeUInt32T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeUInt32(
      _fbb,
      _value);
}

inline TypeUInt64T *TypeUInt64::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeUInt64T>(new TypeUInt64T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeUInt64::UnPackTo(TypeUInt64T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeUInt64> TypeUInt64::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt64T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeUInt64(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeUInt64> CreateTypeUInt64(flatbuffers::FlatBufferBuilder &_fbb, const TypeUInt64T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeUInt64T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeUInt64(
      _fbb,
      _value);
}

inline TypeInt8T *TypeInt8::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeInt8T>(new TypeInt8T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeInt8::UnPackTo(TypeInt8T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeInt8> TypeInt8::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt8T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeInt8(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeInt8> CreateTypeInt8(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt8T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeInt8T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeInt8(
      _fbb,
      _value);
}

inline TypeInt16T *TypeInt16::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeInt16T>(new TypeInt16T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeInt16::UnPackTo(TypeInt16T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeInt16> TypeInt16::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt16T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeInt16(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeInt16> CreateTypeInt16(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt16T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeInt16T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeInt16(
      _fbb,
      _value);
}

inline TypeInt32T *TypeInt32::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeInt32T>(new TypeInt32T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeInt32::UnPackTo(TypeInt32T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeInt32> TypeInt32::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt32T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeInt32(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeInt32> CreateTypeInt32(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt32T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeInt32T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeInt32(
      _fbb,
      _value);
}

inline TypeInt64T *TypeInt64::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeInt64T>(new TypeInt64T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeInt64::UnPackTo(TypeInt64T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeInt64> TypeInt64::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt64T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeInt64(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeInt64> CreateTypeInt64(flatbuffers::FlatBufferBuilder &_fbb, const TypeInt64T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeInt64T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeInt64(
      _fbb,
      _value);
}

inline TypeFloatT *TypeFloat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeFloatT>(new TypeFloatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeFloat::UnPackTo(TypeFloatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeFloat> TypeFloat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeFloat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeFloat> CreateTypeFloat(flatbuffers::FlatBufferBuilder &_fbb, const TypeFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeFloatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeFloat(
      _fbb,
      _value);
}

inline TypeBoolT *TypeBool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeBoolT>(new TypeBoolT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeBool::UnPackTo(TypeBoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeBool> TypeBool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeBool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeBool> CreateTypeBool(flatbuffers::FlatBufferBuilder &_fbb, const TypeBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeBoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeBool(
      _fbb,
      _value);
}

inline TypeDoubleT *TypeDouble::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeDoubleT>(new TypeDoubleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeDouble::UnPackTo(TypeDoubleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeDouble> TypeDouble::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeDoubleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeDouble(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeDouble> CreateTypeDouble(flatbuffers::FlatBufferBuilder &_fbb, const TypeDoubleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeDoubleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeDouble(
      _fbb,
      _value);
}

inline TypeCharT *TypeChar::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeCharT>(new TypeCharT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeChar::UnPackTo(TypeCharT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<TypeChar> TypeChar::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeCharT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeChar(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeChar> CreateTypeChar(flatbuffers::FlatBufferBuilder &_fbb, const TypeCharT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeCharT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return Core::CreateTypeChar(
      _fbb,
      _value);
}

inline bool VerifyAnyValue(flatbuffers::Verifier &verifier, const void *obj, AnyValue type) {
  switch (type) {
    case AnyValue::NONE: {
      return true;
    }
    case AnyValue::TypeUInt8: {
      auto ptr = reinterpret_cast<const Core::TypeUInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeUInt16: {
      auto ptr = reinterpret_cast<const Core::TypeUInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeUInt32: {
      auto ptr = reinterpret_cast<const Core::TypeUInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeUInt64: {
      auto ptr = reinterpret_cast<const Core::TypeUInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeInt8: {
      auto ptr = reinterpret_cast<const Core::TypeInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeInt16: {
      auto ptr = reinterpret_cast<const Core::TypeInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeInt32: {
      auto ptr = reinterpret_cast<const Core::TypeInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeInt64: {
      auto ptr = reinterpret_cast<const Core::TypeInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeFloat: {
      auto ptr = reinterpret_cast<const Core::TypeFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeBool: {
      auto ptr = reinterpret_cast<const Core::TypeBool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeDouble: {
      auto ptr = reinterpret_cast<const Core::TypeDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::TypeChar: {
      auto ptr = reinterpret_cast<const Core::TypeChar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<AnyValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyValue(
        verifier,  values->Get(i), types->GetEnum<AnyValue>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AnyValueUnion::UnPack(const void *obj, AnyValue type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case AnyValue::TypeUInt8: {
      auto ptr = reinterpret_cast<const Core::TypeUInt8 *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeUInt16: {
      auto ptr = reinterpret_cast<const Core::TypeUInt16 *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeUInt32: {
      auto ptr = reinterpret_cast<const Core::TypeUInt32 *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeUInt64: {
      auto ptr = reinterpret_cast<const Core::TypeUInt64 *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeInt8: {
      auto ptr = reinterpret_cast<const Core::TypeInt8 *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeInt16: {
      auto ptr = reinterpret_cast<const Core::TypeInt16 *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeInt32: {
      auto ptr = reinterpret_cast<const Core::TypeInt32 *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeInt64: {
      auto ptr = reinterpret_cast<const Core::TypeInt64 *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeFloat: {
      auto ptr = reinterpret_cast<const Core::TypeFloat *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeBool: {
      auto ptr = reinterpret_cast<const Core::TypeBool *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeDouble: {
      auto ptr = reinterpret_cast<const Core::TypeDouble *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyValue::TypeChar: {
      auto ptr = reinterpret_cast<const Core::TypeChar *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> AnyValueUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case AnyValue::TypeUInt8: {
      auto ptr = reinterpret_cast<const Core::TypeUInt8T *>(value);
      return CreateTypeUInt8(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeUInt16: {
      auto ptr = reinterpret_cast<const Core::TypeUInt16T *>(value);
      return CreateTypeUInt16(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeUInt32: {
      auto ptr = reinterpret_cast<const Core::TypeUInt32T *>(value);
      return CreateTypeUInt32(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeUInt64: {
      auto ptr = reinterpret_cast<const Core::TypeUInt64T *>(value);
      return CreateTypeUInt64(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeInt8: {
      auto ptr = reinterpret_cast<const Core::TypeInt8T *>(value);
      return CreateTypeInt8(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeInt16: {
      auto ptr = reinterpret_cast<const Core::TypeInt16T *>(value);
      return CreateTypeInt16(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeInt32: {
      auto ptr = reinterpret_cast<const Core::TypeInt32T *>(value);
      return CreateTypeInt32(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeInt64: {
      auto ptr = reinterpret_cast<const Core::TypeInt64T *>(value);
      return CreateTypeInt64(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeFloat: {
      auto ptr = reinterpret_cast<const Core::TypeFloatT *>(value);
      return CreateTypeFloat(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeBool: {
      auto ptr = reinterpret_cast<const Core::TypeBoolT *>(value);
      return CreateTypeBool(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeDouble: {
      auto ptr = reinterpret_cast<const Core::TypeDoubleT *>(value);
      return CreateTypeDouble(_fbb, ptr, _rehasher).Union();
    }
    case AnyValue::TypeChar: {
      auto ptr = reinterpret_cast<const Core::TypeCharT *>(value);
      return CreateTypeChar(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AnyValueUnion::AnyValueUnion(const AnyValueUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case AnyValue::TypeUInt8: {
      value = new Core::TypeUInt8T(*reinterpret_cast<Core::TypeUInt8T *>(u.value));
      break;
    }
    case AnyValue::TypeUInt16: {
      value = new Core::TypeUInt16T(*reinterpret_cast<Core::TypeUInt16T *>(u.value));
      break;
    }
    case AnyValue::TypeUInt32: {
      value = new Core::TypeUInt32T(*reinterpret_cast<Core::TypeUInt32T *>(u.value));
      break;
    }
    case AnyValue::TypeUInt64: {
      value = new Core::TypeUInt64T(*reinterpret_cast<Core::TypeUInt64T *>(u.value));
      break;
    }
    case AnyValue::TypeInt8: {
      value = new Core::TypeInt8T(*reinterpret_cast<Core::TypeInt8T *>(u.value));
      break;
    }
    case AnyValue::TypeInt16: {
      value = new Core::TypeInt16T(*reinterpret_cast<Core::TypeInt16T *>(u.value));
      break;
    }
    case AnyValue::TypeInt32: {
      value = new Core::TypeInt32T(*reinterpret_cast<Core::TypeInt32T *>(u.value));
      break;
    }
    case AnyValue::TypeInt64: {
      value = new Core::TypeInt64T(*reinterpret_cast<Core::TypeInt64T *>(u.value));
      break;
    }
    case AnyValue::TypeFloat: {
      value = new Core::TypeFloatT(*reinterpret_cast<Core::TypeFloatT *>(u.value));
      break;
    }
    case AnyValue::TypeBool: {
      value = new Core::TypeBoolT(*reinterpret_cast<Core::TypeBoolT *>(u.value));
      break;
    }
    case AnyValue::TypeDouble: {
      value = new Core::TypeDoubleT(*reinterpret_cast<Core::TypeDoubleT *>(u.value));
      break;
    }
    case AnyValue::TypeChar: {
      value = new Core::TypeCharT(*reinterpret_cast<Core::TypeCharT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void AnyValueUnion::Reset() {
  switch (type) {
    case AnyValue::TypeUInt8: {
      auto ptr = reinterpret_cast<Core::TypeUInt8T *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeUInt16: {
      auto ptr = reinterpret_cast<Core::TypeUInt16T *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeUInt32: {
      auto ptr = reinterpret_cast<Core::TypeUInt32T *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeUInt64: {
      auto ptr = reinterpret_cast<Core::TypeUInt64T *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeInt8: {
      auto ptr = reinterpret_cast<Core::TypeInt8T *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeInt16: {
      auto ptr = reinterpret_cast<Core::TypeInt16T *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeInt32: {
      auto ptr = reinterpret_cast<Core::TypeInt32T *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeInt64: {
      auto ptr = reinterpret_cast<Core::TypeInt64T *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeFloat: {
      auto ptr = reinterpret_cast<Core::TypeFloatT *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeBool: {
      auto ptr = reinterpret_cast<Core::TypeBoolT *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeDouble: {
      auto ptr = reinterpret_cast<Core::TypeDoubleT *>(value);
      delete ptr;
      break;
    }
    case AnyValue::TypeChar: {
      auto ptr = reinterpret_cast<Core::TypeCharT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AnyValue::NONE;
}

}  // namespace Core

#endif  // FLATBUFFERS_GENERATED_TYPES_CORE_H_
