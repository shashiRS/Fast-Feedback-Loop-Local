// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRAFFICPARTICIPANT_GUISCHEMA_H_
#define FLATBUFFERS_GENERATED_TRAFFICPARTICIPANT_GUISCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace GuiSchema {

struct TrafficParticipant;
struct TrafficParticipantBuilder;
struct TrafficParticipantT;

struct TrafficParticipantList;
struct TrafficParticipantListBuilder;
struct TrafficParticipantListT;

enum class TrafficParticipantClass : int32_t {
  None = -1,
  car = 0,
  truck = 1,
  motorcycle = 2,
  pedestrian = 3,
  bicycle = 4,
  MIN = None,
  MAX = bicycle
};

inline const TrafficParticipantClass (&EnumValuesTrafficParticipantClass())[6] {
  static const TrafficParticipantClass values[] = {
    TrafficParticipantClass::None,
    TrafficParticipantClass::car,
    TrafficParticipantClass::truck,
    TrafficParticipantClass::motorcycle,
    TrafficParticipantClass::pedestrian,
    TrafficParticipantClass::bicycle
  };
  return values;
}

inline const char * const *EnumNamesTrafficParticipantClass() {
  static const char * const names[7] = {
    "None",
    "car",
    "truck",
    "motorcycle",
    "pedestrian",
    "bicycle",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrafficParticipantClass(TrafficParticipantClass e) {
  if (flatbuffers::IsOutRange(e, TrafficParticipantClass::None, TrafficParticipantClass::bicycle)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(TrafficParticipantClass::None);
  return EnumNamesTrafficParticipantClass()[index];
}

enum class TrafficParticipantState : int32_t {
  None = -1,
  static_ = 0,
  dyn = 1,
  MIN = None,
  MAX = dyn
};

inline const TrafficParticipantState (&EnumValuesTrafficParticipantState())[3] {
  static const TrafficParticipantState values[] = {
    TrafficParticipantState::None,
    TrafficParticipantState::static_,
    TrafficParticipantState::dyn
  };
  return values;
}

inline const char * const *EnumNamesTrafficParticipantState() {
  static const char * const names[4] = {
    "None",
    "static_",
    "dyn",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrafficParticipantState(TrafficParticipantState e) {
  if (flatbuffers::IsOutRange(e, TrafficParticipantState::None, TrafficParticipantState::dyn)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(TrafficParticipantState::None);
  return EnumNamesTrafficParticipantState()[index];
}

struct TrafficParticipantT : public flatbuffers::NativeTable {
  typedef TrafficParticipant TableType;
  int32_t id = 0;
  float pX = 0.0f;
  float pY = 0.0f;
  float x = 0.0f;
  float y = 0.0f;
  float unifiedYaw = 0.0f;
  float length = 0.0f;
  float width = 0.0f;
  float vX = 0.0f;
  float vY = 0.0f;
  float times = 0.0f;
  int32_t uniqueId = 0;
  int32_t unifiedRefPoint = 0;
  GuiSchema::TrafficParticipantClass unifiedClassIf = GuiSchema::TrafficParticipantClass::car;
  GuiSchema::TrafficParticipantState unifiedDynProp = GuiSchema::TrafficParticipantState::static_;
  std::string sensor{};
  std::string color{};
  float opacity = 0.0f;
  bool braking = false;
  bool indicatingLeft = false;
  bool indicatingRight = false;
  bool showExclamation = false;
  std::string pColor{};
};

struct TrafficParticipant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrafficParticipantT NativeTableType;
  typedef TrafficParticipantBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PX = 6,
    VT_PY = 8,
    VT_X = 10,
    VT_Y = 12,
    VT_UNIFIEDYAW = 14,
    VT_LENGTH = 16,
    VT_WIDTH = 18,
    VT_VX = 20,
    VT_VY = 22,
    VT_TIMES = 24,
    VT_UNIQUEID = 26,
    VT_UNIFIEDREFPOINT = 28,
    VT_UNIFIEDCLASSIF = 30,
    VT_UNIFIEDDYNPROP = 32,
    VT_SENSOR = 34,
    VT_COLOR = 36,
    VT_OPACITY = 38,
    VT_BRAKING = 40,
    VT_INDICATINGLEFT = 42,
    VT_INDICATINGRIGHT = 44,
    VT_SHOWEXCLAMATION = 46,
    VT_PCOLOR = 48
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  float pX() const {
    return GetField<float>(VT_PX, 0.0f);
  }
  float pY() const {
    return GetField<float>(VT_PY, 0.0f);
  }
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float unifiedYaw() const {
    return GetField<float>(VT_UNIFIEDYAW, 0.0f);
  }
  float length() const {
    return GetField<float>(VT_LENGTH, 0.0f);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float vX() const {
    return GetField<float>(VT_VX, 0.0f);
  }
  float vY() const {
    return GetField<float>(VT_VY, 0.0f);
  }
  float times() const {
    return GetField<float>(VT_TIMES, 0.0f);
  }
  int32_t uniqueId() const {
    return GetField<int32_t>(VT_UNIQUEID, 0);
  }
  int32_t unifiedRefPoint() const {
    return GetField<int32_t>(VT_UNIFIEDREFPOINT, 0);
  }
  GuiSchema::TrafficParticipantClass unifiedClassIf() const {
    return static_cast<GuiSchema::TrafficParticipantClass>(GetField<int32_t>(VT_UNIFIEDCLASSIF, 0));
  }
  GuiSchema::TrafficParticipantState unifiedDynProp() const {
    return static_cast<GuiSchema::TrafficParticipantState>(GetField<int32_t>(VT_UNIFIEDDYNPROP, 0));
  }
  const flatbuffers::String *sensor() const {
    return GetPointer<const flatbuffers::String *>(VT_SENSOR);
  }
  const flatbuffers::String *color() const {
    return GetPointer<const flatbuffers::String *>(VT_COLOR);
  }
  float opacity() const {
    return GetField<float>(VT_OPACITY, 0.0f);
  }
  bool braking() const {
    return GetField<uint8_t>(VT_BRAKING, 0) != 0;
  }
  bool indicatingLeft() const {
    return GetField<uint8_t>(VT_INDICATINGLEFT, 0) != 0;
  }
  bool indicatingRight() const {
    return GetField<uint8_t>(VT_INDICATINGRIGHT, 0) != 0;
  }
  bool showExclamation() const {
    return GetField<uint8_t>(VT_SHOWEXCLAMATION, 0) != 0;
  }
  const flatbuffers::String *pColor() const {
    return GetPointer<const flatbuffers::String *>(VT_PCOLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<float>(verifier, VT_PX, 4) &&
           VerifyField<float>(verifier, VT_PY, 4) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_UNIFIEDYAW, 4) &&
           VerifyField<float>(verifier, VT_LENGTH, 4) &&
           VerifyField<float>(verifier, VT_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_VX, 4) &&
           VerifyField<float>(verifier, VT_VY, 4) &&
           VerifyField<float>(verifier, VT_TIMES, 4) &&
           VerifyField<int32_t>(verifier, VT_UNIQUEID, 4) &&
           VerifyField<int32_t>(verifier, VT_UNIFIEDREFPOINT, 4) &&
           VerifyField<int32_t>(verifier, VT_UNIFIEDCLASSIF, 4) &&
           VerifyField<int32_t>(verifier, VT_UNIFIEDDYNPROP, 4) &&
           VerifyOffset(verifier, VT_SENSOR) &&
           verifier.VerifyString(sensor()) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyString(color()) &&
           VerifyField<float>(verifier, VT_OPACITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_BRAKING, 1) &&
           VerifyField<uint8_t>(verifier, VT_INDICATINGLEFT, 1) &&
           VerifyField<uint8_t>(verifier, VT_INDICATINGRIGHT, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHOWEXCLAMATION, 1) &&
           VerifyOffset(verifier, VT_PCOLOR) &&
           verifier.VerifyString(pColor()) &&
           verifier.EndTable();
  }
  TrafficParticipantT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TrafficParticipantT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TrafficParticipant> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrafficParticipantT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TrafficParticipantBuilder {
  typedef TrafficParticipant Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(TrafficParticipant::VT_ID, id, 0);
  }
  void add_pX(float pX) {
    fbb_.AddElement<float>(TrafficParticipant::VT_PX, pX, 0.0f);
  }
  void add_pY(float pY) {
    fbb_.AddElement<float>(TrafficParticipant::VT_PY, pY, 0.0f);
  }
  void add_x(float x) {
    fbb_.AddElement<float>(TrafficParticipant::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(TrafficParticipant::VT_Y, y, 0.0f);
  }
  void add_unifiedYaw(float unifiedYaw) {
    fbb_.AddElement<float>(TrafficParticipant::VT_UNIFIEDYAW, unifiedYaw, 0.0f);
  }
  void add_length(float length) {
    fbb_.AddElement<float>(TrafficParticipant::VT_LENGTH, length, 0.0f);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(TrafficParticipant::VT_WIDTH, width, 0.0f);
  }
  void add_vX(float vX) {
    fbb_.AddElement<float>(TrafficParticipant::VT_VX, vX, 0.0f);
  }
  void add_vY(float vY) {
    fbb_.AddElement<float>(TrafficParticipant::VT_VY, vY, 0.0f);
  }
  void add_times(float times) {
    fbb_.AddElement<float>(TrafficParticipant::VT_TIMES, times, 0.0f);
  }
  void add_uniqueId(int32_t uniqueId) {
    fbb_.AddElement<int32_t>(TrafficParticipant::VT_UNIQUEID, uniqueId, 0);
  }
  void add_unifiedRefPoint(int32_t unifiedRefPoint) {
    fbb_.AddElement<int32_t>(TrafficParticipant::VT_UNIFIEDREFPOINT, unifiedRefPoint, 0);
  }
  void add_unifiedClassIf(GuiSchema::TrafficParticipantClass unifiedClassIf) {
    fbb_.AddElement<int32_t>(TrafficParticipant::VT_UNIFIEDCLASSIF, static_cast<int32_t>(unifiedClassIf), 0);
  }
  void add_unifiedDynProp(GuiSchema::TrafficParticipantState unifiedDynProp) {
    fbb_.AddElement<int32_t>(TrafficParticipant::VT_UNIFIEDDYNPROP, static_cast<int32_t>(unifiedDynProp), 0);
  }
  void add_sensor(flatbuffers::Offset<flatbuffers::String> sensor) {
    fbb_.AddOffset(TrafficParticipant::VT_SENSOR, sensor);
  }
  void add_color(flatbuffers::Offset<flatbuffers::String> color) {
    fbb_.AddOffset(TrafficParticipant::VT_COLOR, color);
  }
  void add_opacity(float opacity) {
    fbb_.AddElement<float>(TrafficParticipant::VT_OPACITY, opacity, 0.0f);
  }
  void add_braking(bool braking) {
    fbb_.AddElement<uint8_t>(TrafficParticipant::VT_BRAKING, static_cast<uint8_t>(braking), 0);
  }
  void add_indicatingLeft(bool indicatingLeft) {
    fbb_.AddElement<uint8_t>(TrafficParticipant::VT_INDICATINGLEFT, static_cast<uint8_t>(indicatingLeft), 0);
  }
  void add_indicatingRight(bool indicatingRight) {
    fbb_.AddElement<uint8_t>(TrafficParticipant::VT_INDICATINGRIGHT, static_cast<uint8_t>(indicatingRight), 0);
  }
  void add_showExclamation(bool showExclamation) {
    fbb_.AddElement<uint8_t>(TrafficParticipant::VT_SHOWEXCLAMATION, static_cast<uint8_t>(showExclamation), 0);
  }
  void add_pColor(flatbuffers::Offset<flatbuffers::String> pColor) {
    fbb_.AddOffset(TrafficParticipant::VT_PCOLOR, pColor);
  }
  explicit TrafficParticipantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrafficParticipant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrafficParticipant>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrafficParticipant> CreateTrafficParticipant(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    float pX = 0.0f,
    float pY = 0.0f,
    float x = 0.0f,
    float y = 0.0f,
    float unifiedYaw = 0.0f,
    float length = 0.0f,
    float width = 0.0f,
    float vX = 0.0f,
    float vY = 0.0f,
    float times = 0.0f,
    int32_t uniqueId = 0,
    int32_t unifiedRefPoint = 0,
    GuiSchema::TrafficParticipantClass unifiedClassIf = GuiSchema::TrafficParticipantClass::car,
    GuiSchema::TrafficParticipantState unifiedDynProp = GuiSchema::TrafficParticipantState::static_,
    flatbuffers::Offset<flatbuffers::String> sensor = 0,
    flatbuffers::Offset<flatbuffers::String> color = 0,
    float opacity = 0.0f,
    bool braking = false,
    bool indicatingLeft = false,
    bool indicatingRight = false,
    bool showExclamation = false,
    flatbuffers::Offset<flatbuffers::String> pColor = 0) {
  TrafficParticipantBuilder builder_(_fbb);
  builder_.add_pColor(pColor);
  builder_.add_opacity(opacity);
  builder_.add_color(color);
  builder_.add_sensor(sensor);
  builder_.add_unifiedDynProp(unifiedDynProp);
  builder_.add_unifiedClassIf(unifiedClassIf);
  builder_.add_unifiedRefPoint(unifiedRefPoint);
  builder_.add_uniqueId(uniqueId);
  builder_.add_times(times);
  builder_.add_vY(vY);
  builder_.add_vX(vX);
  builder_.add_width(width);
  builder_.add_length(length);
  builder_.add_unifiedYaw(unifiedYaw);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_pY(pY);
  builder_.add_pX(pX);
  builder_.add_id(id);
  builder_.add_showExclamation(showExclamation);
  builder_.add_indicatingRight(indicatingRight);
  builder_.add_indicatingLeft(indicatingLeft);
  builder_.add_braking(braking);
  return builder_.Finish();
}

inline flatbuffers::Offset<TrafficParticipant> CreateTrafficParticipantDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    float pX = 0.0f,
    float pY = 0.0f,
    float x = 0.0f,
    float y = 0.0f,
    float unifiedYaw = 0.0f,
    float length = 0.0f,
    float width = 0.0f,
    float vX = 0.0f,
    float vY = 0.0f,
    float times = 0.0f,
    int32_t uniqueId = 0,
    int32_t unifiedRefPoint = 0,
    GuiSchema::TrafficParticipantClass unifiedClassIf = GuiSchema::TrafficParticipantClass::car,
    GuiSchema::TrafficParticipantState unifiedDynProp = GuiSchema::TrafficParticipantState::static_,
    const char *sensor = nullptr,
    const char *color = nullptr,
    float opacity = 0.0f,
    bool braking = false,
    bool indicatingLeft = false,
    bool indicatingRight = false,
    bool showExclamation = false,
    const char *pColor = nullptr) {
  auto sensor__ = sensor ? _fbb.CreateString(sensor) : 0;
  auto color__ = color ? _fbb.CreateString(color) : 0;
  auto pColor__ = pColor ? _fbb.CreateString(pColor) : 0;
  return GuiSchema::CreateTrafficParticipant(
      _fbb,
      id,
      pX,
      pY,
      x,
      y,
      unifiedYaw,
      length,
      width,
      vX,
      vY,
      times,
      uniqueId,
      unifiedRefPoint,
      unifiedClassIf,
      unifiedDynProp,
      sensor__,
      color__,
      opacity,
      braking,
      indicatingLeft,
      indicatingRight,
      showExclamation,
      pColor__);
}

flatbuffers::Offset<TrafficParticipant> CreateTrafficParticipant(flatbuffers::FlatBufferBuilder &_fbb, const TrafficParticipantT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TrafficParticipantListT : public flatbuffers::NativeTable {
  typedef TrafficParticipantList TableType;
  std::vector<std::unique_ptr<GuiSchema::TrafficParticipantT>> trafficParticipants{};
  TrafficParticipantListT() = default;
  TrafficParticipantListT(const TrafficParticipantListT &o);
  TrafficParticipantListT(TrafficParticipantListT&&) FLATBUFFERS_NOEXCEPT = default;
  TrafficParticipantListT &operator=(TrafficParticipantListT o) FLATBUFFERS_NOEXCEPT;
};

struct TrafficParticipantList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrafficParticipantListT NativeTableType;
  typedef TrafficParticipantListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRAFFICPARTICIPANTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::TrafficParticipant>> *trafficParticipants() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GuiSchema::TrafficParticipant>> *>(VT_TRAFFICPARTICIPANTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRAFFICPARTICIPANTS) &&
           verifier.VerifyVector(trafficParticipants()) &&
           verifier.VerifyVectorOfTables(trafficParticipants()) &&
           verifier.EndTable();
  }
  TrafficParticipantListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TrafficParticipantListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TrafficParticipantList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrafficParticipantListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TrafficParticipantListBuilder {
  typedef TrafficParticipantList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trafficParticipants(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::TrafficParticipant>>> trafficParticipants) {
    fbb_.AddOffset(TrafficParticipantList::VT_TRAFFICPARTICIPANTS, trafficParticipants);
  }
  explicit TrafficParticipantListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrafficParticipantList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrafficParticipantList>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrafficParticipantList> CreateTrafficParticipantList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GuiSchema::TrafficParticipant>>> trafficParticipants = 0) {
  TrafficParticipantListBuilder builder_(_fbb);
  builder_.add_trafficParticipants(trafficParticipants);
  return builder_.Finish();
}

inline flatbuffers::Offset<TrafficParticipantList> CreateTrafficParticipantListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GuiSchema::TrafficParticipant>> *trafficParticipants = nullptr) {
  auto trafficParticipants__ = trafficParticipants ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::TrafficParticipant>>(*trafficParticipants) : 0;
  return GuiSchema::CreateTrafficParticipantList(
      _fbb,
      trafficParticipants__);
}

flatbuffers::Offset<TrafficParticipantList> CreateTrafficParticipantList(flatbuffers::FlatBufferBuilder &_fbb, const TrafficParticipantListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TrafficParticipantT *TrafficParticipant::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TrafficParticipantT>(new TrafficParticipantT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TrafficParticipant::UnPackTo(TrafficParticipantT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = pX(); _o->pX = _e; }
  { auto _e = pY(); _o->pY = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = unifiedYaw(); _o->unifiedYaw = _e; }
  { auto _e = length(); _o->length = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = vX(); _o->vX = _e; }
  { auto _e = vY(); _o->vY = _e; }
  { auto _e = times(); _o->times = _e; }
  { auto _e = uniqueId(); _o->uniqueId = _e; }
  { auto _e = unifiedRefPoint(); _o->unifiedRefPoint = _e; }
  { auto _e = unifiedClassIf(); _o->unifiedClassIf = _e; }
  { auto _e = unifiedDynProp(); _o->unifiedDynProp = _e; }
  { auto _e = sensor(); if (_e) _o->sensor = _e->str(); }
  { auto _e = color(); if (_e) _o->color = _e->str(); }
  { auto _e = opacity(); _o->opacity = _e; }
  { auto _e = braking(); _o->braking = _e; }
  { auto _e = indicatingLeft(); _o->indicatingLeft = _e; }
  { auto _e = indicatingRight(); _o->indicatingRight = _e; }
  { auto _e = showExclamation(); _o->showExclamation = _e; }
  { auto _e = pColor(); if (_e) _o->pColor = _e->str(); }
}

inline flatbuffers::Offset<TrafficParticipant> TrafficParticipant::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrafficParticipantT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTrafficParticipant(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TrafficParticipant> CreateTrafficParticipant(flatbuffers::FlatBufferBuilder &_fbb, const TrafficParticipantT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TrafficParticipantT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _pX = _o->pX;
  auto _pY = _o->pY;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _unifiedYaw = _o->unifiedYaw;
  auto _length = _o->length;
  auto _width = _o->width;
  auto _vX = _o->vX;
  auto _vY = _o->vY;
  auto _times = _o->times;
  auto _uniqueId = _o->uniqueId;
  auto _unifiedRefPoint = _o->unifiedRefPoint;
  auto _unifiedClassIf = _o->unifiedClassIf;
  auto _unifiedDynProp = _o->unifiedDynProp;
  auto _sensor = _o->sensor.empty() ? 0 : _fbb.CreateString(_o->sensor);
  auto _color = _o->color.empty() ? 0 : _fbb.CreateString(_o->color);
  auto _opacity = _o->opacity;
  auto _braking = _o->braking;
  auto _indicatingLeft = _o->indicatingLeft;
  auto _indicatingRight = _o->indicatingRight;
  auto _showExclamation = _o->showExclamation;
  auto _pColor = _o->pColor.empty() ? 0 : _fbb.CreateString(_o->pColor);
  return GuiSchema::CreateTrafficParticipant(
      _fbb,
      _id,
      _pX,
      _pY,
      _x,
      _y,
      _unifiedYaw,
      _length,
      _width,
      _vX,
      _vY,
      _times,
      _uniqueId,
      _unifiedRefPoint,
      _unifiedClassIf,
      _unifiedDynProp,
      _sensor,
      _color,
      _opacity,
      _braking,
      _indicatingLeft,
      _indicatingRight,
      _showExclamation,
      _pColor);
}

inline TrafficParticipantListT::TrafficParticipantListT(const TrafficParticipantListT &o) {
  trafficParticipants.reserve(o.trafficParticipants.size());
  for (const auto &v : o.trafficParticipants) { trafficParticipants.emplace_back((v) ? new GuiSchema::TrafficParticipantT(*v) : nullptr); }
}

inline TrafficParticipantListT &TrafficParticipantListT::operator=(TrafficParticipantListT o) FLATBUFFERS_NOEXCEPT {
  std::swap(trafficParticipants, o.trafficParticipants);
  return *this;
}

inline TrafficParticipantListT *TrafficParticipantList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TrafficParticipantListT>(new TrafficParticipantListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TrafficParticipantList::UnPackTo(TrafficParticipantListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = trafficParticipants(); if (_e) { _o->trafficParticipants.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->trafficParticipants[_i]) { _e->Get(_i)->UnPackTo(_o->trafficParticipants[_i].get(), _resolver); } else { _o->trafficParticipants[_i] = std::unique_ptr<GuiSchema::TrafficParticipantT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<TrafficParticipantList> TrafficParticipantList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrafficParticipantListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTrafficParticipantList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TrafficParticipantList> CreateTrafficParticipantList(flatbuffers::FlatBufferBuilder &_fbb, const TrafficParticipantListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TrafficParticipantListT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _trafficParticipants = _o->trafficParticipants.size() ? _fbb.CreateVector<flatbuffers::Offset<GuiSchema::TrafficParticipant>> (_o->trafficParticipants.size(), [](size_t i, _VectorArgs *__va) { return CreateTrafficParticipant(*__va->__fbb, __va->__o->trafficParticipants[i].get(), __va->__rehasher); }, &_va ) : 0;
  return GuiSchema::CreateTrafficParticipantList(
      _fbb,
      _trafficParticipants);
}

inline const GuiSchema::TrafficParticipantList *GetTrafficParticipantList(const void *buf) {
  return flatbuffers::GetRoot<GuiSchema::TrafficParticipantList>(buf);
}

inline const GuiSchema::TrafficParticipantList *GetSizePrefixedTrafficParticipantList(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<GuiSchema::TrafficParticipantList>(buf);
}

inline const char *TrafficParticipantListIdentifier() {
  return "TP01";
}

inline bool TrafficParticipantListBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, TrafficParticipantListIdentifier());
}

inline bool SizePrefixedTrafficParticipantListBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, TrafficParticipantListIdentifier(), true);
}

inline bool VerifyTrafficParticipantListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GuiSchema::TrafficParticipantList>(TrafficParticipantListIdentifier());
}

inline bool VerifySizePrefixedTrafficParticipantListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GuiSchema::TrafficParticipantList>(TrafficParticipantListIdentifier());
}

inline void FinishTrafficParticipantListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GuiSchema::TrafficParticipantList> root) {
  fbb.Finish(root, TrafficParticipantListIdentifier());
}

inline void FinishSizePrefixedTrafficParticipantListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GuiSchema::TrafficParticipantList> root) {
  fbb.FinishSizePrefixed(root, TrafficParticipantListIdentifier());
}

inline std::unique_ptr<GuiSchema::TrafficParticipantListT> UnPackTrafficParticipantList(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GuiSchema::TrafficParticipantListT>(GetTrafficParticipantList(buf)->UnPack(res));
}

inline std::unique_ptr<GuiSchema::TrafficParticipantListT> UnPackSizePrefixedTrafficParticipantList(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GuiSchema::TrafficParticipantListT>(GetSizePrefixedTrafficParticipantList(buf)->UnPack(res));
}

}  // namespace GuiSchema

#endif  // FLATBUFFERS_GENERATED_TRAFFICPARTICIPANT_GUISCHEMA_H_
