// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CUSTOMPOINTCLOUD_TEST_H_
#define FLATBUFFERS_GENERATED_CUSTOMPOINTCLOUD_TEST_H_

#include "flatbuffers/flatbuffers.h"

namespace test {

struct ExtraInfo;
struct ExtraInfoBuilder;
struct ExtraInfoT;

struct PointCloud;
struct PointCloudBuilder;
struct PointCloudT;

struct PointCloudWrapper;
struct PointCloudWrapperBuilder;
struct PointCloudWrapperT;

struct ExtraInfoT : public flatbuffers::NativeTable {
  typedef ExtraInfo TableType;
  int32_t someData = 0;
  int32_t someOtherData = 0;
};

struct ExtraInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExtraInfoT NativeTableType;
  typedef ExtraInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_SOMEDATA = 4, VT_SOMEOTHERDATA = 6 };
  int32_t someData() const { return GetField<int32_t>(VT_SOMEDATA, 0); }
  int32_t someOtherData() const { return GetField<int32_t>(VT_SOMEOTHERDATA, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_SOMEDATA, 4) &&
           VerifyField<int32_t>(verifier, VT_SOMEOTHERDATA, 4) && verifier.EndTable();
  }
  ExtraInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExtraInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExtraInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtraInfoT *_o,
                                             const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExtraInfoBuilder {
  typedef ExtraInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_someData(int32_t someData) { fbb_.AddElement<int32_t>(ExtraInfo::VT_SOMEDATA, someData, 0); }
  void add_someOtherData(int32_t someOtherData) {
    fbb_.AddElement<int32_t>(ExtraInfo::VT_SOMEOTHERDATA, someOtherData, 0);
  }
  explicit ExtraInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<ExtraInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExtraInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExtraInfo> CreateExtraInfo(flatbuffers::FlatBufferBuilder &_fbb, int32_t someData = 0,
                                                      int32_t someOtherData = 0) {
  ExtraInfoBuilder builder_(_fbb);
  builder_.add_someOtherData(someOtherData);
  builder_.add_someData(someData);
  return builder_.Finish();
}

struct ExtraInfo::Traits {
  using type = ExtraInfo;
  static auto constexpr Create = CreateExtraInfo;
};

flatbuffers::Offset<ExtraInfo> CreateExtraInfo(flatbuffers::FlatBufferBuilder &_fbb, const ExtraInfoT *_o,
                                               const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointCloudT : public flatbuffers::NativeTable {
  typedef PointCloud TableType;
  std::vector<float> points{};
  std::vector<float> pointColors{};
  std::string color{};
  int32_t sensorUid = 0;
  std::vector<std::unique_ptr<test::ExtraInfoT>> pointsExtraInfo{};
  PointCloudT() = default;
  PointCloudT(const PointCloudT &o);
  PointCloudT(PointCloudT &&) FLATBUFFERS_NOEXCEPT = default;
  PointCloudT &operator=(PointCloudT o) FLATBUFFERS_NOEXCEPT;
};

struct PointCloud FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointCloudT NativeTableType;
  typedef PointCloudBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4,
    VT_POINTCOLORS = 6,
    VT_COLOR = 8,
    VT_SENSORUID = 10,
    VT_POINTSEXTRAINFO = 12
  };
  const flatbuffers::Vector<float> *points() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_POINTS); }
  const flatbuffers::Vector<float> *pointColors() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_POINTCOLORS);
  }
  const flatbuffers::String *color() const { return GetPointer<const flatbuffers::String *>(VT_COLOR); }
  int32_t sensorUid() const { return GetField<int32_t>(VT_SENSORUID, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<test::ExtraInfo>> *pointsExtraInfo() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<test::ExtraInfo>> *>(VT_POINTSEXTRAINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_POINTS) && verifier.VerifyVector(points()) &&
           VerifyOffset(verifier, VT_POINTCOLORS) && verifier.VerifyVector(pointColors()) &&
           VerifyOffset(verifier, VT_COLOR) && verifier.VerifyString(color()) &&
           VerifyField<int32_t>(verifier, VT_SENSORUID, 4) && VerifyOffset(verifier, VT_POINTSEXTRAINFO) &&
           verifier.VerifyVector(pointsExtraInfo()) && verifier.VerifyVectorOfTables(pointsExtraInfo()) &&
           verifier.EndTable();
  }
  PointCloudT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointCloudT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PointCloud> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointCloudT *_o,
                                              const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointCloudBuilder {
  typedef PointCloud Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<float>> points) {
    fbb_.AddOffset(PointCloud::VT_POINTS, points);
  }
  void add_pointColors(flatbuffers::Offset<flatbuffers::Vector<float>> pointColors) {
    fbb_.AddOffset(PointCloud::VT_POINTCOLORS, pointColors);
  }
  void add_color(flatbuffers::Offset<flatbuffers::String> color) { fbb_.AddOffset(PointCloud::VT_COLOR, color); }
  void add_sensorUid(int32_t sensorUid) { fbb_.AddElement<int32_t>(PointCloud::VT_SENSORUID, sensorUid, 0); }
  void
  add_pointsExtraInfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<test::ExtraInfo>>> pointsExtraInfo) {
    fbb_.AddOffset(PointCloud::VT_POINTSEXTRAINFO, pointsExtraInfo);
  }
  explicit PointCloudBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<PointCloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointCloud>(end);
    return o;
  }
};

inline flatbuffers::Offset<PointCloud>
CreatePointCloud(flatbuffers::FlatBufferBuilder &_fbb, flatbuffers::Offset<flatbuffers::Vector<float>> points = 0,
                 flatbuffers::Offset<flatbuffers::Vector<float>> pointColors = 0,
                 flatbuffers::Offset<flatbuffers::String> color = 0, int32_t sensorUid = 0,
                 flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<test::ExtraInfo>>> pointsExtraInfo = 0) {
  PointCloudBuilder builder_(_fbb);
  builder_.add_pointsExtraInfo(pointsExtraInfo);
  builder_.add_sensorUid(sensorUid);
  builder_.add_color(color);
  builder_.add_pointColors(pointColors);
  builder_.add_points(points);
  return builder_.Finish();
}

struct PointCloud::Traits {
  using type = PointCloud;
  static auto constexpr Create = CreatePointCloud;
};

inline flatbuffers::Offset<PointCloud>
CreatePointCloudDirect(flatbuffers::FlatBufferBuilder &_fbb, const std::vector<float> *points = nullptr,
                       const std::vector<float> *pointColors = nullptr, const char *color = nullptr,
                       int32_t sensorUid = 0,
                       const std::vector<flatbuffers::Offset<test::ExtraInfo>> *pointsExtraInfo = nullptr) {
  auto points__ = points ? _fbb.CreateVector<float>(*points) : 0;
  auto pointColors__ = pointColors ? _fbb.CreateVector<float>(*pointColors) : 0;
  auto color__ = color ? _fbb.CreateString(color) : 0;
  auto pointsExtraInfo__ =
      pointsExtraInfo ? _fbb.CreateVector<flatbuffers::Offset<test::ExtraInfo>>(*pointsExtraInfo) : 0;
  return test::CreatePointCloud(_fbb, points__, pointColors__, color__, sensorUid, pointsExtraInfo__);
}

flatbuffers::Offset<PointCloud> CreatePointCloud(flatbuffers::FlatBufferBuilder &_fbb, const PointCloudT *_o,
                                                 const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PointCloudWrapperT : public flatbuffers::NativeTable {
  typedef PointCloudWrapper TableType;
  std::vector<std::unique_ptr<test::PointCloudT>> pointClouds{};
  PointCloudWrapperT() = default;
  PointCloudWrapperT(const PointCloudWrapperT &o);
  PointCloudWrapperT(PointCloudWrapperT &&) FLATBUFFERS_NOEXCEPT = default;
  PointCloudWrapperT &operator=(PointCloudWrapperT o) FLATBUFFERS_NOEXCEPT;
};

struct PointCloudWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointCloudWrapperT NativeTableType;
  typedef PointCloudWrapperBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_POINTCLOUDS = 4 };
  const flatbuffers::Vector<flatbuffers::Offset<test::PointCloud>> *pointClouds() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<test::PointCloud>> *>(VT_POINTCLOUDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_POINTCLOUDS) &&
           verifier.VerifyVector(pointClouds()) && verifier.VerifyVectorOfTables(pointClouds()) && verifier.EndTable();
  }
  PointCloudWrapperT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PointCloudWrapperT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PointCloudWrapper> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointCloudWrapperT *_o,
                                                     const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PointCloudWrapperBuilder {
  typedef PointCloudWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pointClouds(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<test::PointCloud>>> pointClouds) {
    fbb_.AddOffset(PointCloudWrapper::VT_POINTCLOUDS, pointClouds);
  }
  explicit PointCloudWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset<PointCloudWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointCloudWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<PointCloudWrapper> CreatePointCloudWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<test::PointCloud>>> pointClouds = 0) {
  PointCloudWrapperBuilder builder_(_fbb);
  builder_.add_pointClouds(pointClouds);
  return builder_.Finish();
}

struct PointCloudWrapper::Traits {
  using type = PointCloudWrapper;
  static auto constexpr Create = CreatePointCloudWrapper;
};

inline flatbuffers::Offset<PointCloudWrapper>
CreatePointCloudWrapperDirect(flatbuffers::FlatBufferBuilder &_fbb,
                              const std::vector<flatbuffers::Offset<test::PointCloud>> *pointClouds = nullptr) {
  auto pointClouds__ = pointClouds ? _fbb.CreateVector<flatbuffers::Offset<test::PointCloud>>(*pointClouds) : 0;
  return test::CreatePointCloudWrapper(_fbb, pointClouds__);
}

flatbuffers::Offset<PointCloudWrapper>
CreatePointCloudWrapper(flatbuffers::FlatBufferBuilder &_fbb, const PointCloudWrapperT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ExtraInfoT *ExtraInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ExtraInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExtraInfo::UnPackTo(ExtraInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = someData();
    _o->someData = _e;
  }
  {
    auto _e = someOtherData();
    _o->someOtherData = _e;
  }
}

inline flatbuffers::Offset<ExtraInfo> ExtraInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtraInfoT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExtraInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExtraInfo> CreateExtraInfo(flatbuffers::FlatBufferBuilder &_fbb, const ExtraInfoT *_o,
                                                      const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const ExtraInfoT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _someData = _o->someData;
  auto _someOtherData = _o->someOtherData;
  return test::CreateExtraInfo(_fbb, _someData, _someOtherData);
}

inline PointCloudT::PointCloudT(const PointCloudT &o)
    : points(o.points), pointColors(o.pointColors), color(o.color), sensorUid(o.sensorUid) {
  pointsExtraInfo.reserve(o.pointsExtraInfo.size());
  for (const auto &v : o.pointsExtraInfo) {
    pointsExtraInfo.emplace_back((v) ? new test::ExtraInfoT(*v) : nullptr);
  }
}

inline PointCloudT &PointCloudT::operator=(PointCloudT o) FLATBUFFERS_NOEXCEPT {
  std::swap(points, o.points);
  std::swap(pointColors, o.pointColors);
  std::swap(color, o.color);
  std::swap(sensorUid, o.sensorUid);
  std::swap(pointsExtraInfo, o.pointsExtraInfo);
  return *this;
}

inline PointCloudT *PointCloud::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PointCloudT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointCloud::UnPackTo(PointCloudT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = points();
    if (_e) {
      _o->points.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        _o->points[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = pointColors();
    if (_e) {
      _o->pointColors.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        _o->pointColors[_i] = _e->Get(_i);
      }
    }
  }
  {
    auto _e = color();
    if (_e)
      _o->color = _e->str();
  }
  {
    auto _e = sensorUid();
    _o->sensorUid = _e;
  }
  {
    auto _e = pointsExtraInfo();
    if (_e) {
      _o->pointsExtraInfo.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->pointsExtraInfo[_i]) {
          _e->Get(_i)->UnPackTo(_o->pointsExtraInfo[_i].get(), _resolver);
        } else {
          _o->pointsExtraInfo[_i] = std::unique_ptr<test::ExtraInfoT>(_e->Get(_i)->UnPack(_resolver));
        };
      }
    }
  }
}

inline flatbuffers::Offset<PointCloud> PointCloud::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointCloudT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointCloud(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PointCloud> CreatePointCloud(flatbuffers::FlatBufferBuilder &_fbb, const PointCloudT *_o,
                                                        const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const PointCloudT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _points = _o->points.size() ? _fbb.CreateVector(_o->points) : 0;
  auto _pointColors = _o->pointColors.size() ? _fbb.CreateVector(_o->pointColors) : 0;
  auto _color = _o->color.empty() ? 0 : _fbb.CreateString(_o->color);
  auto _sensorUid = _o->sensorUid;
  auto _pointsExtraInfo =
      _o->pointsExtraInfo.size()
          ? _fbb.CreateVector<flatbuffers::Offset<test::ExtraInfo>>(
                _o->pointsExtraInfo.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreateExtraInfo(*__va->__fbb, __va->__o->pointsExtraInfo[i].get(), __va->__rehasher);
                },
                &_va)
          : 0;
  return test::CreatePointCloud(_fbb, _points, _pointColors, _color, _sensorUid, _pointsExtraInfo);
}

inline PointCloudWrapperT::PointCloudWrapperT(const PointCloudWrapperT &o) {
  pointClouds.reserve(o.pointClouds.size());
  for (const auto &v : o.pointClouds) {
    pointClouds.emplace_back((v) ? new test::PointCloudT(*v) : nullptr);
  }
}

inline PointCloudWrapperT &PointCloudWrapperT::operator=(PointCloudWrapperT o) FLATBUFFERS_NOEXCEPT {
  std::swap(pointClouds, o.pointClouds);
  return *this;
}

inline PointCloudWrapperT *PointCloudWrapper::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<PointCloudWrapperT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PointCloudWrapper::UnPackTo(PointCloudWrapperT *_o,
                                        const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  {
    auto _e = pointClouds();
    if (_e) {
      _o->pointClouds.resize(_e->size());
      for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
        if (_o->pointClouds[_i]) {
          _e->Get(_i)->UnPackTo(_o->pointClouds[_i].get(), _resolver);
        } else {
          _o->pointClouds[_i] = std::unique_ptr<test::PointCloudT>(_e->Get(_i)->UnPack(_resolver));
        };
      }
    }
  }
}

inline flatbuffers::Offset<PointCloudWrapper>
PointCloudWrapper::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PointCloudWrapperT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePointCloudWrapper(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PointCloudWrapper>
CreatePointCloudWrapper(flatbuffers::FlatBufferBuilder &_fbb, const PointCloudWrapperT *_o,
                        const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs {
    flatbuffers::FlatBufferBuilder *__fbb;
    const PointCloudWrapperT *__o;
    const flatbuffers::rehasher_function_t *__rehasher;
  } _va = {&_fbb, _o, _rehasher};
  (void)_va;
  auto _pointClouds =
      _o->pointClouds.size()
          ? _fbb.CreateVector<flatbuffers::Offset<test::PointCloud>>(
                _o->pointClouds.size(),
                [](size_t i, _VectorArgs *__va) {
                  return CreatePointCloud(*__va->__fbb, __va->__o->pointClouds[i].get(), __va->__rehasher);
                },
                &_va)
          : 0;
  return test::CreatePointCloudWrapper(_fbb, _pointClouds);
}

inline const test::PointCloudWrapper *GetPointCloudWrapper(const void *buf) {
  return flatbuffers::GetRoot<test::PointCloudWrapper>(buf);
}

inline const test::PointCloudWrapper *GetSizePrefixedPointCloudWrapper(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<test::PointCloudWrapper>(buf);
}

inline bool VerifyPointCloudWrapperBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<test::PointCloudWrapper>(nullptr);
}

inline bool VerifySizePrefixedPointCloudWrapperBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<test::PointCloudWrapper>(nullptr);
}

inline void FinishPointCloudWrapperBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                          flatbuffers::Offset<test::PointCloudWrapper> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPointCloudWrapperBuffer(flatbuffers::FlatBufferBuilder &fbb,
                                                      flatbuffers::Offset<test::PointCloudWrapper> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<test::PointCloudWrapperT>
UnPackPointCloudWrapper(const void *buf, const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<test::PointCloudWrapperT>(GetPointCloudWrapper(buf)->UnPack(res));
}

inline std::unique_ptr<test::PointCloudWrapperT>
UnPackSizePrefixedPointCloudWrapper(const void *buf, const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<test::PointCloudWrapperT>(GetSizePrefixedPointCloudWrapper(buf)->UnPack(res));
}

} // namespace test

#endif // FLATBUFFERS_GENERATED_CUSTOMPOINTCLOUD_TEST_H_
