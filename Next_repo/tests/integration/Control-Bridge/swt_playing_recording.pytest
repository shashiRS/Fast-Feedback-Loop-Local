"""
    Copyright 2022 Continental Corporation

    :file: swt_playing_recording.pytest
    :platform: Windows, Linux
    :synopsis:
        Script containing test case(s) for playing a recording over the ControlBridge

    :author:
        - Fabian Janker (uif41320) <fabian.janker@continental-corporation.com>
        - Alexandru Buraga (uic928270) <alexandru.2.buraga@continental-corporation.com>
"""

# standard Python import area
import json
import time

from helper_files.ControlBridge import controlbridge_Variables
from helper_files.General import global_Variables
from ptf.ptf_utils.global_params import get_parameter
from ptf.ptf_utils.report import (
    DETAILS,
    EXPECTED,
    PRECONDITION,
    TESTSTEP,
    TESTTAG,
    VERIFIES,
)
from ptf.verify_utils import ptf_asserts, ptf_expects


def SWT_REC_PLAYING_EVENT_TEST():
    DETAILS("Test case to check if the event of playing the recording is correct")

    VERIFIES("The test is verifying, that the event is correct")

    TESTTAG("blackbox")
    TESTTAG("integration")
    TESTTAG("design-driven")
    TESTTAG("sil")
    TESTTAG("controlbridge")

    PRECONDITION("ControlBridge, DataBridge & Next_Player has started (global setup)")
    PRECONDITION("Connection to the ControlBridge and DataBridge")

    # getting the next_api
    next_api = get_parameter("next_api")

    PRECONDITION("Load recording.")
    # sending the message to load a recording into the player
    recording_path = global_Variables.recording_dir()
    recv_load_recording = next_api.execute.load_recording(recording_path)
    ptf_asserts.verify(bool(recv_load_recording), True, "Timeout while loading the recording. Message received: {}".format(recv_load_recording))
    PRECONDITION("Recording is loaded")

    try:
        TESTSTEP("Start to play the recording")
        # sending the message to play the recording and receive the response
        response_play = next_api.execute.play_recording()
        # if controlbridge_websocket returns False, a timeout has occurred
        ptf_asserts.verify(bool(response_play), True, "Timeout while playing the recording. Message received: {}".format(response_play))
        TESTSTEP("Recording is played")

        TESTSTEP("POSTCONDITION: Stop the recording")
        EXPECTED("Recording is paused properly")
        # sending the message to pause a recording
        response_paused = next_api.execute.pause_recording()
        # if controlbridge_websocket returns False, a timeout has occurred
        ptf_asserts.verify(bool(response_paused), True, "Timeout while pausing the recording. Message received: {}".format(response_paused))
    except Exception as e:
        ptf_expects.fail(e)
    finally:
        TESTSTEP("POSTCONDITION: Close the recording")
        EXPECTED("event: SimulationStateIsIdle")
        recv_close_recording = next_api.execute.close_recording()
        ptf_asserts.verify(bool(recv_close_recording), True, "Timeout while closing the recording. Message received: {}".format(recv_close_recording))
        TESTSTEP("POSTCONDITION: Recording is closed")

# test case is disabled:
# The currentTimeStamp is not between startTimeStamp and endTimeStamp of the event PlaybackIsPlaying
# The issue seems to be from the Recording, the timestamp value is not increasing all the time and at some time is bellow to start timestamp value
def SWT_REC_PLAYING_PAYLOAD_TEST():
    DETAILS("Test case to check if the payload of playing the recording is correct")

    VERIFIES("The test is verifying, that the payload is correct")

    TESTTAG("blackbox")
    TESTTAG("integration")
    TESTTAG("design-driven")
    TESTTAG("sil")
    TESTTAG("controlbridge")

    PRECONDITION("ControlBridge, DataBridge & Next_Player has started (global setup)")
    PRECONDITION("Connection to the ControlBridge and DataBridge")

    # getting the next_api
    next_api = get_parameter("next_api")

    PRECONDITION("Load recording.")
    # sending the message to load a recording into the player
    recording_path = global_Variables.recording_dir()
    recv_load_recording = next_api.execute.load_recording(recording_path)
    ptf_asserts.verify(bool(recv_load_recording), True, "Timeout while loading the recording. Message received: {}".format(recv_load_recording))
    PRECONDITION("Recording is loaded")

    try:
        current_timestamp_loading = recv_load_recording["payload"]["currentTimestamp"]

        TESTSTEP("Start to play the recording")
        # sending the message to play the recording and receive the response
        response_start_play = next_api.execute.play_recording()
        # if controlbridge_websocket returns False, a timeout has occurred
        ptf_asserts.verify(bool(response_start_play), True, "Timeout while playing the recording. Message received: {}".format(response_start_play))
        TESTSTEP("Recording is played")

        TESTSTEP("Wait 10 seconds and get the recording")
        time.sleep(5)
        response_play = next_api.websocket.controlbridge.recv(receive_channel=controlbridge_Variables.RECEIVE_CHANNEL_PLAYER)
        response_json_play = json.loads(response_play)
        response_event_play = response_json_play["event"]
        while response_event_play != controlbridge_Variables.EXPECTED_EVENT_PLAYBACK_PLAYING:
            response_play = next_api.websocket.controlbridge.recv(receive_channel=controlbridge_Variables.RECEIVE_CHANNEL_PLAYER)
            response_json_play = json.loads(response_play)
            response_event_play = response_json_play["event"]
            print("response {}".format(response_json_play))

        TESTSTEP("Checking if the payload of playing a recording is correct")
        EXPECTED("payload: startTimestamp >= currentTimestamp_of_loading")
        EXPECTED("payload: endTimestamp >= startTimestamp")
        EXPECTED("payload: currentTimestamp >= startTimestamp AND currentTimestamp <= endTimestamp")
        EXPECTED("payload: speedMultiple >= 0")
        EXPECTED("payload: unit == us")

        recv_start_timestamp = response_json_play["payload"]["startTimeStamp"]
        recv_end_timestamp = response_json_play["payload"]["endTimeStamp"]
        recv_current_timestamp = response_json_play["payload"]["currentTimestamp"]
        recv_speed_multiple = response_json_play["payload"]["speedMultiple"]
        recv_unit = response_json_play["payload"]["unit"]
        # Checking if the payload is correct
        ptf_expects.expect_gt_eq(
            recv_start_timestamp,
            current_timestamp_loading,
            "The startTimestamp of the loaded Recording is not " "greater equal than the loaded currentTimeStamp",
        )
        ptf_expects.expect_gt_eq(
            recv_end_timestamp,
            recv_start_timestamp,
            "The endTimestamp of the loaded recording is not " "greater equal than the loaded currentTimeStamp",
        )
        ptf_expects.expect_in_range(
            recv_start_timestamp,
            recv_end_timestamp,
            recv_current_timestamp,
            "The currentTimeStamp is not between " "startTimeStamp and endTimeStamp",
        )
        ptf_expects.expect_gt_eq(
            recv_speed_multiple, 0, "The speedMultiple of the loaded recording " "is not greater equal 0!"
        )
        ptf_expects.expect_eq(recv_unit, "us", "the unit is not the expected string!")

        TESTSTEP("POSTCONDITION: Stop the recording")
        EXPECTED("Recording is paused properly")
        # sending the message to pause a recording
        response_paused = next_api.execute.pause_recording()
        # if controlbridge_websocket returns False, a timeout has occurred
        ptf_asserts.verify(bool(response_paused), True, "Timeout while pausing the recording. Message received: {}".format(response_paused))

    except TypeError:
        ptf_expects.fail("Payload is wrong: {}".format(response_json_play))
    finally:
        TESTSTEP("POSTCONDITION: Close the recording")
        EXPECTED("event: SimulationStateIsIdle")
        recv_close_recording = next_api.execute.close_recording()
        ptf_asserts.verify(bool(recv_close_recording), True, "Timeout while closing the recording. Message received: {}".format(recv_close_recording))
        TESTSTEP("POSTCONDITION: Recording is closed")
