"""
    Copyright 2022 Continental Corporation

    :file: swt_jump_to_beginning.pytest
    :platform: Windows, Linux
    :synopsis:
        Script containing test case(s) for jumping to the beginning over the ControlBridge

    :author:
        - Fabian Janker (uif41320) <fabian.janker@continental-corporation.com>
        - Alexandru Buraga (uic928270) <alexandru.2.buraga@continental-corporation.com>
"""

import json
import random
import time

from helper_files.ControlBridge import controlbridge_Variables
from helper_files.General import global_Variables
from ptf.ptf_utils.global_params import get_parameter
from ptf.ptf_utils.report import (
    DETAILS,
    EXPECTED,
    PRECONDITION,
    TESTSTEP,
    TESTTAG,
    VERIFIES,
)
from ptf.verify_utils import ptf_asserts, ptf_expects


def SWT_JUMP_TO_BEGINNING_EVENT_TEST():
    DETAILS("Test case to check if the event of jump to beginning is correct")

    VERIFIES("The test is verifying, that the event is correct")

    TESTTAG("blackbox")
    TESTTAG("integration")
    TESTTAG("design-driven")
    TESTTAG("sil")
    TESTTAG("controlbridge")

    PRECONDITION("ControlBridge, DataBridge & Next_Player has started (global setup)")
    PRECONDITION("Connection to the ControlBridge and DataBridge")

    # getting the next_api
    next_api = get_parameter("next_api")

    PRECONDITION("Load recording.")
    # sending the message to load a recording into the player
    recording_path = global_Variables.recording_dir(is_zrec=True)
    recv_load_recording = next_api.execute.load_recording(recording_path)
    ptf_asserts.verify(bool(recv_load_recording), True, "Timeout while loading the recording. Message received: {}".format(recv_load_recording))
    PRECONDITION("Recording is loaded")

    try:
        PRECONDITION("Start to play the recording")
        # sending the message to play the recording and receive the response
        response_play = next_api.execute.play_recording()
        # if controlbridge_websocket returns False, a timeout has occurred
        ptf_asserts.verify(bool(response_play), True, "Timeout while playing the recording. Message received: {}".format(response_play))
        PRECONDITION(" Recording is played")

        # waiting a random number between 10ms to 100ms before pausing the recording
        time.sleep(random.uniform(0.01, 0.1))

        PRECONDITION("Pause recording")
        response_paused = next_api.execute.pause_recording()
        # if next_api_websocket returns False, a timeout has occurred
        ptf_asserts.verify(bool(response_paused), True, "Timeout while pausing the recording.")
        PRECONDITION("The recording is paused")

        TESTSTEP("Send command 'Jump to Beginning'")
        EXPECTED("Following event returned: PlaybackIsPaused")
        response_jump_to_beginning = next_api.execute.jump_to_beginning()
        # if next_api_websocket returns False, a timeout has occurred
        ptf_asserts.verify(bool(response_jump_to_beginning), True, "Timeout while jumping to beginning of the recording")
        TESTSTEP("Command 'Jump to Beginning' is executed")
        TESTSTEP("Check the event response")
        recv_event_jump_to_beginning = response_jump_to_beginning["event"]
        # checking if the expected event is correct
        ptf_expects.expect_eq(
            recv_event_jump_to_beginning,
            controlbridge_Variables.EXPECTED_EVENT_JUMP_TO_BEGINNING,
            "The event received is not the expected string!. Message received: {}".format(recv_event_jump_to_beginning),
        )
        TESTSTEP("The event received is the expected string '{}'!".format(controlbridge_Variables.EXPECTED_EVENT_JUMP_TO_BEGINNING))
    except Exception as e:
        ptf_expects.fail(e)
    finally:
        TESTSTEP("POSTCONDITION: Close the recording")
        EXPECTED("event: SimulationStateIsIdle")
        recv_close_recording = next_api.execute.close_recording()
        ptf_asserts.verify(bool(recv_close_recording), True, "Timeout while closing the recording. Message received: {}".format(recv_close_recording))
        TESTSTEP("POSTCONDITION: Recording is closed")


def SWT_JUMP_TO_BEGINNING_PAYLOAD_TEST():
    DETAILS("Test case to check if the payload of jump to beginning is correct")

    VERIFIES("The test is verifying, that the payload is correct")

    TESTTAG("blackbox")
    TESTTAG("integration")
    TESTTAG("design-driven")
    TESTTAG("sil")
    TESTTAG("controlbridge")

    PRECONDITION("ControlBridge, DataBridge & Next_Player has started (global setup)")
    PRECONDITION("Connection to the ControlBridge and DataBridge")

    # getting the next_api
    next_api = get_parameter("next_api")

    PRECONDITION("Load recording.")
    # sending the message to load a recording into the player
    recording_path = global_Variables.recording_dir(is_zrec=True)
    recv_load_recording = next_api.execute.load_recording(recording_path)
    ptf_asserts.verify(bool(recv_load_recording), True, "Timeout while loading the recording. Message received: {}".format(recv_load_recording))
    PRECONDITION("Recording is loaded")

    try:
        PRECONDITION("Start to play the recording")
        # sending the message to play the recording and receive the response
        response_play = next_api.execute.play_recording()
        # if controlbridge_websocket returns False, a timeout has occurred
        ptf_asserts.verify(bool(response_play), True, "Timeout while playing the recording. Message received: {}".format(response_play))
        PRECONDITION("Recording is played")

        recv_start_timestamp = response_play["payload"]["startTimeStamp"]

        # waiting a random number between 10ms to 100ms before pausing the recording
        time.sleep(random.uniform(0.01, 0.1))

        PRECONDITION("Start to pause the recording")
        response_paused = next_api.execute.pause_recording()
        # if next_api_websocket returns False, a timeout has occurred
        ptf_asserts.verify(bool(response_paused), True, "Timeout while pausing the recording.")
        PRECONDITION("Recording is paused")

        TESTSTEP("Send the command 'Jump to Beginning'")
        EXPECTED("received payload with: currentTimestamp == startTimestamp")
        response_jump_to_beginning = next_api.execute.jump_to_beginning()
        # if controlbridge_websocket returns False, a timeout has occurred
        ptf_asserts.verify(
            bool(response_jump_to_beginning), True, "Timeout while jumping to the beginning the recording."
        )

        recv_current_timestamp = response_jump_to_beginning["payload"]["currentTimestamp"]
        # checking if the expected event is correct
        ptf_expects.expect_eq(recv_current_timestamp, recv_start_timestamp, "currentTimestamp != startTimestamp")

    except Exception as e:
        ptf_expects.fail(e)
    finally:
        TESTSTEP("POSTCONDITION: Close the recording")
        EXPECTED("event: SimulationStateIsIdle")
        recv_close_recording = next_api.execute.close_recording()
        ptf_asserts.verify(bool(recv_close_recording), True, "Timeout while closing the recording. Message received: {}".format(recv_close_recording))
        TESTSTEP("POSTCONDITION: Recording is closed")
