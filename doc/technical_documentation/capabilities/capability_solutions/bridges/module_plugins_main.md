Plugins {#module_plugins_main}
======

System Plugins Overview
* @ref plugins_system_signal_exporter
* @ref plugins_system_regex_searcher

---

[TOC]

# Overview {#plugins_overview}

The Data Bridge has a Plugin SDK that allows developers to test and deploy project-specific plugins during runtime.

The Plugins are shared library packages that can be loaded dynamically during runtime. They typically consist of a folder containing pre-compiled `.dll` and configuration files.

They allow for project-specific frameworks to render data in a more general way so that it can be used by other components, e.g., to convert the data into a user-friendly format like `JSON`, which will be used by a GUI to display it along with other signals.

This way, the plugin framework allows for a complete separation of development from other individual plugins and the *NEXT-Bridges* core, as well as multiple versions and deployment testing during runtime.

# Description {#plugins_description}

A Plugin is a project-specific framework that operates with signal specific data. E.g. the plugin `fdp_base_roadmodel` contains the algorithms to convert the *Road Model Data* present in a specific recording into lines that can be displayed on the ground in a 3D Visualization environment. Another example is the *Point Cloud plugin* that will convert the raw sensor measurements into visualization data in the GUI.

The Plugins framework can also contain plugins that are *utility-based* for the GUI. For instance the `Table View` plugin, allows for manually exploring the signals present in a recording; The `Performance Viewer` plugin provides simulation performance metrics to the GUI.

---

# Plugin framework description {#plugins_framework_description}

The main *NEXT Data Bridge* cycle has different managers that handle different components of its core functionality. One of these components is the *Plugin Manager*, which handles all the plugin related services.

The *Plugin Manager* starts by looking for plugins in the sub-folder `plugins`, that should be local to the `databridge.exe` location, e.g.:

<img src="plugins_compiled_location.png" width="223">

All the valid plugins that the *Plugin Manager* finds are added to a list of possible plugins (along with their configurations) that the *NEXT Data Bridge* will interface and handle related requests to.

A plugin in itself is simply a folder with a set of files:

1. `<plugin_name>.dll` *on Windows* or `<plugin_name>.so` *on Linux*
2. `<plugin_name>.fbs`

In order to get the `.dll` or `.so` of the plugin, it needs to be generated. During build time this is compiled from the `<Next-Bridges>/src/Plugins/<plugin_name>` folder.

The `.fbs` file contains the Flatbuffer schema description of the plugin-specific data structure. This file can be either fully *custom* or copied from the default schemas folder in `<Next-Bridges>/src/BridgeSDK/interface/schema`.

> Note: The `schema` folder contains also the *Flatbuffer compiler generated* `.h` files from the corresponding `.fbs` file. If a custom structure is needed, these `.h` files should be generated by the plugin developer and be contained in the plugin specific implementation. Note that all the automatically generated `.h` files will have a message indicating this, as a comment on the first line.

The following is a description of what is necessary to create and deploy a plugin.

---

## The base class: plugin.h {#plugins_plugin_h}

All the plugins inherit from the `next::bridge_sdk::plugin::Plugin` class, defined in `plugin.h`.

On a functional level, a plugin should have the following sets of functions:

1. Initialization
2. Configuration changes
3. Callbacks
4. Communication

### 1 - Plugin initialization {#plugins_plugin_h_initalization}

The initialization functions of a plugin consist of the class *instantiation* and *initialization*.

These are defined in the plugin class constructor and an `init()` function.

When the *Plugin Manager* searches the plugins directory and finds the different valid plugins, it instantiates them *temporarily*, therefore calling the plugin class constructor. After this is done, they are added to a list of *available plugins*.

The `init()` function is called on the first receipt of a request for that plugin, effectively initializing the plugin. All the functionality for the plugin initialization should be defined there, and not on the constructor.

#### 1.1 - Constructor {#plugins_plugin_h_initalization_construct}

In the plugin constructor should be all the functionality needed for the plugin instantiation (before the initialization).

> Note: The constructor is called a first time when the *Plugin Manager* is validating a plugin's dll. This is only done temporarily as to get a reference in memory. As soon as this validation is done, the object is destroyed for performance reasons. When the first request to the plugin will be received, the constructor will be called again, right before the `init()` function.

Some important properties that should be set are:

1. setName() - `std::string` Set the plugin identifier name

2. setVersion() - `std::string` Set the plugin version number

> Format: `<major>.<minor>[.patch][-<additionalText>]`

Also, the plugin constructor receives the plugin's `path` as input.

##### 1.1.1 - The path input parameter

For better understanding of the plugins input `path` parameter, a description of how the *Plugin manager* looks for and adds the plugins is necessary:

The *Plugin Manager* scans a path (hardcoded in main as `plugins`) inside the executable local folder (i.e., inside the conan_workspace/release/bin/). How: the `plugin_manager.cpp` calls its `init()` function, which inside calls the `scanDirectory()` function.

The `scanDirectory()` function iterates through the `plugins` directory, recursively, saving and using the folder's name as the `plugin name`, and looking inside for the `.dll` file.

Inside the `.dll` it looks for a function called `create_plugin`. If the dll doesn't have this function, the plugin is not added.

This function is called, and it is the compiled function that needs to be inside every plugin for a plugin to be instantiated.

The `create_plugin` function is a static constructor of the plugin. For example in `fdp_base_roadmodel.cpp`: `plugin_create_t create_plugin(const char *path) { return new next::plugins::VisuRoadModel(path);`, which basically calls the plugin constructor, and passes it the plugin `path`.

So, in summary, the plugin class input parameter `path`, is simply the directory where the compiled plugin dll is.

#### 1.2 - init() function {#plugins_plugin_h_initalization_init}

Once the *Plugin Manager* instantiates a valid plugin, it's ready to receive requests directed at that plugin. The *Data Class Manager/Data Request Server* handles it, and as soon as the first request for that specific plugin arrives, its `init()` function is called.

In this function, all the plugin initialization related functionality should be started.

One important feature of the plugins is the *addons* functions, which separate the `plugin.h` main class into multiple functional components, e.g., the *3D Visualizer* related plugins, should make use of the `plugin_3D_view.h` functions.

For this reason, all the *addons* that the plugin will make use of, should be initialized here also.

Example:

Let's consider the `FdpBaseRoad` plugin, which handles the *Road Model* data: `fdp_base_roadmodel.h`

This plugin uses 3 addons:

1. Signal Explorer - `next::bridge_sdk::plugin::PluginSignalExplorer`
2. 3D View - `next::bridge_sdk::plugin::Plugin3dView`
3. Data Subscriber - `next::bridge_sdk::plugin::PluginDataSubscriber`

So in its `init()` function, all 3 addons should be initialized.

---

TODO: continue from there



### 2 - CreateInstance function



### 3 - getDescription



### 4 - addConfig



### 5-removeConfig

---

TODO: move to another section

## 2-Flatbuffer schema and getDescription function


## 3-GUI and addConfig


## 4-removeConfig

---

TODO: previous idea

# Howto run a plugin {#plugins_howto}

. Introduction - overall, how to make it work. The trigger for the data classes from the GUI side, the instantiation on the plugin manager, the initialization on the widgets->plugin manager, and the trigger for the plugin functions callbacks of each plugin.
. Link to the Howto section for the simple explanation
. Continue the explanation, but go more deep now: where the plugins are located and fbs schema (), Data Bridge main, log messages of plugin manager, explain better the data class manager functionality not just from the GUI side, flatbuffer send, json send, etc
. Example - TP objects or fdp21p, but look for a recording that contains them? or pointcloud (not polygon)

# Plugin creation tutorial {#plugins_tutorial}

. Use an example and follow that, describe only superficially the different functionality. It will be described more in detail in the following section
. Give hints for the different addons/wrappers, and their functionality from the end user in the GUI perspective.

---

# Plugins framework {#plugins_framework}

## 1 - Overview

. Try not to repeat the intro from the #plugins_howto

## 2 - Plugin class

. The main class

### Plugin private

. Look into the code

## Plugin Addons

. Explain the plugin class wrappers

### Plugin 3D view

### Plugin Data Subscriber

### Plugin Data Publisher

### Plugin utils

---

## Plugin management

### Main databridge cycle

. Describe the plugins part of the main databridge cycle: initialization of plugin manager and configuration manager, requests to the plugin manager queue, etc
. This is also important for crystal clear understanding of the Plugin Decoupling architecture review task

### Configuration Manager `configuration_manager.h`

The **Configuration Manager** allows the specification of configuration parameters related to the **Next Bridges** operation: `Plugins` and `Websocket` information. This is a file in the `JSON` format.

The `Plugins` information forces a specific plugin to be activated and run at launch time.

The `Websocket` information relates to the **ports** for the Data endpoints: `Requests` server and `Broadcast`.

#### Default mode

By default, when the Data Bridge process is launched with no input parameters, the Configuration Manager assumes no input `Plugins` or `Webserver` information.

. The default port for Websocket Requests is `8082`.

. The default port for UDP Broadcasting is `8080`.

#### config_file_mode

To enter `config_file_mode`, when the Data Bridge is launched, add the paramater `-configfile` followed by the path to the `databridge_configuration.json` file. E.g.:

```cmd
.\databridge.exe -configfile databridge_configuration.json
```

The `databridge_configuration.json` file format should be:

TODO: look into the tests

```JSON
{
  "defaultPlugin": {
    "plugin_1": {plugin_1_user_args},
    "plugin_2": {plugin_2_user_args},
  },
  "WebServerConfig": {
    "DataBroadcaster": {
      "ip": "127.0.0.1",
      "port": 8080,
    },
    "RequestServer": {
      "ip": "127.0.0.1",
      "port": 8082,
    },
  },
}
```

. ~~The `defaultPlugin` key may contain a set of unique plugins, and the user input arguments.~~ Deprecated.

. The `WebServerConfig` may contain the information related to the `WebServerConfig` or `RequestServer`, `ip` and `port`.

In case of missing or defective fields, the **Configuration Manager** will revert to the default values as described above.

### Plugin Manager

The **Plugin Manager** is the main component to handle the individual Plugins.

During the main **Data Bridge** startup, the **Plugin Manager** looks for the available plugins and initializes them. Only when a request for a specific plugin is received, the plugins are triggered and their callbacks are attached.

TODO: describe queue.

#### fbs schema

---

# Plugin testing

TODO
