Overview {#overview_main}
==============

[TOC]

# Simulation Network

<img src="overview_next.png" width="800">

# Data Flow

A small layer around the internally managed middleware \named{eCAL}\glos{eCAL} is used to manage data-types, simulation metadata and publisher subscriber relations.
All data is sent via its binary representation to safe computational effort with respect to serialization and deserialization in contrast to systems using protobuf or similar toolings.
As eCAL only transmits data which is actually subscribed a lot of performance is gained.
The effort of interpreting data is only done when needed.<br>
To publish data into the system a DataPublisher can be created with help of \named{NEXT UDex}. To receive data a DataSubscriber is also available within \named{NEXT UDex}.<br>
When using Cobolt as a code generator all of this functionality is incoroporated within the NEXT Sim SDK which provides automatic build of NEXT Simulation nodes. 
To access simulation data the \named{NEXT Bridges} come into play. They provide functionality to tap into simulation data on a URL basis without the struggle of maintaining any \named{NEXT UDex} components with help of their plugins. 

# Simulation Network Requirements

To contribute to the NEXT Simulation Network the use of \named{NEXT UDex} and its utilities is highly recommended.
To register within the network the _DataPublisher (file: Next_UDex/data_publisher.h)_ of \named{NEXT UDex} is to be used.
It provides functionality to register a data source with help of so-called SDL files.
They are a representation of the underlying data structure and can be autogenerated by \named{COBOLT}.
There it is also highly encouraged to use \named{COBOLT} for code generation.
When using the \named{COBOLT} code generation all simulation nodes will be automatically set up correctly when using the correct plattform and settings.<br>
An example of this configuration can be seen in \named{CEM200} on an example branch _origin/feature/SIMEN-4169/NextTestEnvironment_. A more detailed explanation of the required steps can be found at [integration](@ref integration_main).

To subscribe to the network a duo of a _DataSuscriber (file: Next_UDex/data_subscriber.h)_ and _DataExtractor (file: Next_UDex/data_extractor.h)_ is needed. 
The _DataSubscriber_ handles the data input flow from eCAL and forwards it to the _DataExtractor_ which allows for \named{GIA} integration and data interpretation. 
This is especially important for non-trivial signals like \named{ethernet data} or \named{can data}.

> üìù All of the above-mentioned toolings can also be circumvented by using plain eCAL publishers. This is not recommended as key features like the \named{Table view} and automatic signal parsing are lost. Subscribing to those eCAL publishers is nevertheless supported but will result in plain binary data transmission.


@section CapabilitySolutions Capability Solutions

A typical example simulation network\glos{simulation_network} consists of multiple \named{capability solutions}\glos{capability_solution} running on a system:
* \named{NEXT Player}\glos{player} for reading and inserting recorded data into the simulation network
* \named{NEXT Bridges}\glos{bridges} for accessing simulation network data and post-processing data for example for visualization
* \named{NEXT Component Interface}\glos{component_interface} for introducing components under test (CuT) into the simulation network
* \named{NEXT GUI} to visualize the post-processed data via a web-based rendering engine


@section CapabilityModules Capability Modules

The \named{NEXT}\glos{NEXT} simulation framework is an open network which emphasises on modularity. Core capability modules are available for all tasks and requirements and are used over different capabiliy solutions.

To help and cope with project needs and sustain a managed simulation network additional components are packed into shared libraries:
* \named{NEXT UDex}\glos{udex} to cope with network registration and data management
* \named{NEXT Control}\glos{control} to allow for synchronization, event handling and component orchestration
* \named{NEXT CoreSDK}\glos{core_sdk} to support generic tools for developing like logging, crash dumps, config management, performance tracking


@section NEXTVision Next Visions

The previously described splits between low-level \named{capability modules}\glos{capability_module} and high-level \named{capability solutions}\glos{capability_solution} enables multiple key visions of NEXT
* fast adaption
* simplification of integration 
* ease-of use start
* bottom-up integration

All in all Next wants to allow for fast adaption in new projects. Create a ease-of use application for stabilized projects and scale better with larger projects.
To allow for this the bottom-up integration take a huge part which is a direct result of the modulartiy.
If a first simultion network is set up we have a setup roughly like the one shown below.

<img src="bottom_up_integration.png" alt="Bottom Up integration first iteration" width="800">

For a stable project this could be delivered either as simple modules as seen on the left or as a big monolithic executable on the right.
The monolithic block can even be faster and easier maintained and shared as it is a single component. The problem starts with switching for example the data source.
If the data is now from a virtual scenario and synthezited we need to integrate each and every component again into the new system.
With the extendable and modularized system it is only changing on component. All other parts (visualization, logging etc.) can stay the same.

This is more and more relevant for larger and more complex systems as this natural way of extending modules helps to keep dependencies and interfaces clean and therefor 
allows for better scaling with project size and users.

This contrast can be seen in the below graphics where for the virutal data provider all has to be changed for the top-down approach but only a single component is switched in the bottom-up approach.

<img src="bottom_up_integration_after.png" alt="Bottom Up integration first iteration" width="800">

